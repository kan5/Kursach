[
{"source_link": "https://metanit.com/sql/postgresql/1.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 16.08.2021", "title": "Что такое PostgreSQL. Установка сервера", "text": "\n Введение в PostgreSQL Что такое PostgreSQL. Установка сервера Последнее обновление: 16.08.2021 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n PostgreSQL является одной из наиболее популярных систем управления базами данных. Сам проект postgresql эволюционировал из другого проекта, который назывался Ingres. Формально развитие postgresql началось еще в 1986 году. Тогда он назывался POSTGRES. \r\nА в 1996 году проект был переименован в PostgreSQL, что отражало больший акцент на SQL. И собственно 8 июля 1996 года состоялся первый релиз продукта. \r\n С тех пор вышло множество версий postgresql. Текущей версией является версия 13. Однако регулярно также выходят подверсии. \r\n PostgreSQL поддерживается для всех основных операционных систем - Windows, Linux, MacOS. \r\n Официальный сайт проекта:  https://www.postgresql.org/ . \r\n PostgreSQL развивается как opensource. Исходный код проекта можно найти в репозитории на гитхабе по адресу  https://github.com/postgres/postgres . \r\n Установка \r\n На странице  https://www.postgresql.org/download/  можно найти ссылки на \r\nзагрузку различных дистрибутивов для различных операционных систем. В частности, для загрузки дистрибутива для Windows, а также для MacOS надо перейти на \r\nстраницу  https://www.enterprisedb.com/downloads/postgres-postgresql-downloads  \r\nи указать все необходимые опции для загрузки: версию postgres и операционную систему. В моем случае ОС - Windows 10 64х, поэтому я выбираю соответствующий пункт-  Windows x86-64 \r\n \r\n Тут же можно найти дитрибутивы и для других систем. \r\n Запустим программу установки: \r\n \r\n На следующем экране необходимо будет указать папку для установки. Оставим папку по умолчанию и перейдем к следующему шагу: \r\n \r\n Далее будет предложено выбрать компоненты для установки: \r\n \r\n Оставим все компоненты по умолчанию и перейдем к следующему шагу. Далее будет предложено выбрать папку, где будут храниться базы данных: \r\n \r\n Оставим путь по умолчанию и перейдем к следующему шагу. Затем необходимо будет установить пароль для суперпользователя  postgres : \r\n \r\n При установке запомним пароль, так как он потребуется для подключения к серверу. Затем нужно будет установить порт, по которому будет запускаться сервер. Можно оставить порт по умолчанию: \r\n \r\n Далее можно будет установить локаль сервера. Оставим установку по умолчанию: \r\n \r\n После этого мы увидим сводку по всем настройкам: \r\n \r\n И если нас все устраивает, то можно нажать на кнопку Next, и начнется установка \r\n \r\n И после завершения установки мы увидем следующее окно, и для выхода нажмем на кнопку Finish: \r\n \r\n Таким образом, сервер PostgreSQL установлен, и мы можем начинать с ним работать. \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Введение в PostgreSQL</h1><h2>Что такое PostgreSQL. Установка сервера</h2><div class=\"date\">Последнее обновление: 16.08.2021</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>PostgreSQL является одной из наиболее популярных систем управления базами данных. Сам проект postgresql эволюционировал из другого проекта, который назывался Ingres. Формально развитие postgresql началось еще в 1986 году. Тогда он назывался POSTGRES. \r\nА в 1996 году проект был переименован в PostgreSQL, что отражало больший акцент на SQL. И собственно 8 июля 1996 года состоялся первый релиз продукта.</p>\r\n<p>С тех пор вышло множество версий postgresql. Текущей версией является версия 13. Однако регулярно также выходят подверсии.</p>\r\n<p>PostgreSQL поддерживается для всех основных операционных систем - Windows, Linux, MacOS.</p>\r\n<p>Официальный сайт проекта: <a href=\"https://www.postgresql.org/\" rel=\"nofollow\">https://www.postgresql.org/</a>.</p>\r\n<p>PostgreSQL развивается как opensource. Исходный код проекта можно найти в репозитории на гитхабе по адресу <a href=\"https://github.com/postgres/postgres\" rel=\"nofollow\">https://github.com/postgres/postgres</a>.</p>\r\n<h3>Установка</h3>\r\n<p>На странице <a href=\"https://www.postgresql.org/download/\" rel=\"nofollow\">https://www.postgresql.org/download/</a> можно найти ссылки на \r\nзагрузку различных дистрибутивов для различных операционных систем. В частности, для загрузки дистрибутива для Windows, а также для MacOS надо перейти на \r\nстраницу <a href=\"https://www.enterprisedb.com/downloads/postgres-postgresql-downloads\" rel=\"nofollow\">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a> \r\nи указать все необходимые опции для загрузки: версию postgres и операционную систему. В моем случае ОС - Windows 10 64х, поэтому я выбираю соответствующий пункт- <span class=\"b\">Windows x86-64</span></p>\r\n<img src=\"./pics/postgres10.png\" alt=\"Загрузка дистрибутива PostgreSQL для Windows\">\r\n<p>Тут же можно найти дитрибутивы и для других систем.</p>\r\n<p>Запустим программу установки:</p>\r\n<img src=\"./pics/postgres1.png\" alt=\"Установка PostgreSQL\">\r\n<p>На следующем экране необходимо будет указать папку для установки. Оставим папку по умолчанию и перейдем к следующему шагу:</p>\r\n<img src=\"./pics/postgres2.png\">\r\n<p>Далее будет предложено выбрать компоненты для установки:</p>\r\n<img src=\"./pics/postgres3.png\" alt=\"Установка компонентов PostgreSQL\">\r\n<p>Оставим все компоненты по умолчанию и перейдем к следующему шагу. Далее будет предложено выбрать папку, где будут храниться базы данных:</p>\r\n<img src=\"./pics/postgres4.png\" alt=\"Установка каталога баз данных для PostgreSQL\">\r\n<p>Оставим путь по умолчанию и перейдем к следующему шагу. Затем необходимо будет установить пароль для суперпользователя <span class=\"b\">postgres</span>:</p>\r\n<img src=\"./pics/postgres5.png\" alt=\"Установка пароля для PostgreSQL\">\r\n<p>При установке запомним пароль, так как он потребуется для подключения к серверу. Затем нужно будет установить порт, по которому будет запускаться сервер. Можно оставить порт по умолчанию:</p>\r\n<img src=\"./pics/postgres6.png\" alt=\"Установка порта для PostgreSQL\">\r\n<p>Далее можно будет установить локаль сервера. Оставим установку по умолчанию:</p>\r\n<img src=\"./pics/postgres7.png\" alt=\"Установка локали для PostgreSQL\">\r\n<p>После этого мы увидим сводку по всем настройкам:</p>\r\n<img src=\"./pics/postgres8.png\" alt=\"Настройки установки сервера PostgreSQL\">\r\n<p>И если нас все устраивает, то можно нажать на кнопку Next, и начнется установка</p>\r\n<img src=\"./pics/postgres11.png\" alt=\"Процесс установки сервера PostgreSQL\">\r\n<p>И после завершения установки мы увидем следующее окно, и для выхода нажмем на кнопку Finish:</p>\r\n<img src=\"./pics/postgres9.png\" alt=\"Завершение установки сервера PostgreSQL\">\r\n<p>Таким образом, сервер PostgreSQL установлен, и мы можем начинать с ним работать.</p>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"./\">Назад</a><a href=\"./\">Содержание</a><a href=\"./1.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/1.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 15.03.2018", "title": "Графический клиент pgAdmin", "text": "\n Графический клиент pgAdmin Последнее обновление: 15.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для упрощения администрирования на сервере postgresql в базовый комплект установки входит такой инструмент как  pgAdmin . \r\nОн представляет графический клиент для работы с сервером, через который мы в удобном виде можем создавать, удалять, изменять базы данных и управлять ими. \r\nТак, на Windows после установки мы можем найти значок pgAdmin в меню Пуск и запустить его: \r\n \r\n После этого нам откроется следующая программа: \r\n \r\n Теперь подключимся к серверу PostgreSQL. Для этого в левой части окна программы раскроем пункт Servers, который содержит набор серверов PostgreSQL. \r\nПри установке последней версии устанавливается сервер, который по умолчанию имеет название  PostgreSQL 10 . Нажмем на этот пункт, \r\nи нам отобразится окно для ввода пароля: \r\n \r\n Здесь необходимо ввести пароль для суперпользователя postgres, который был задан при установке PostgreSQL. \r\n После успешного логина нам откроется содержимое сервера: \r\n \r\n В частности, в узле  Databases  мы можем увидеть все имеющиеся базы данных. По умолчанию здесь есть только одна база данных - postgres. \r\n Также в правой части мы можем увидеть узел  Login/Group Roles , который предназначен для управления пользователями и их ролями. \r\n И третий узел -  Tablespaces  позволяет управлять местом хранения файлов баз данных. \r\n Теперь создадим свою базу данных. Для этого нажмем правой кнопкой мыши на узел  Databases . И далее в контекстном меню \r\nвыберем  Create -> Database... \r\n \r\n После этого нам отобразится окно для создания базы данных. Введем название для БД, например,  test1  и нажмем на кнопку \r\n\"Save\": \r\n \r\n После этого в древовидном меню слева отобразится содержимое созданной базы данных test1: \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Графический клиент pgAdmin</h2><div class=\"date\">Последнее обновление: 15.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для упрощения администрирования на сервере postgresql в базовый комплект установки входит такой инструмент как <span class=\"b\">pgAdmin</span>. \r\nОн представляет графический клиент для работы с сервером, через который мы в удобном виде можем создавать, удалять, изменять базы данных и управлять ими. \r\nТак, на Windows после установки мы можем найти значок pgAdmin в меню Пуск и запустить его:</p>\r\n<img src=\"pics/pgadmin1.png\" alt=\"pgAdmin в Windows\">\r\n<p>После этого нам откроется следующая программа:</p>\r\n<img src=\"pics/pgadmin2.png\" alt=\"pgAdmin и PostgreSQL\">\r\n<p>Теперь подключимся к серверу PostgreSQL. Для этого в левой части окна программы раскроем пункт Servers, который содержит набор серверов PostgreSQL. \r\nПри установке последней версии устанавливается сервер, который по умолчанию имеет название <span class=\"b\">PostgreSQL 10</span>. Нажмем на этот пункт, \r\nи нам отобразится окно для ввода пароля:</p>\r\n<img src=\"pics/pgadmin3.png\" alt=\"Логин в pgAdmin\">\r\n<p>Здесь необходимо ввести пароль для суперпользователя postgres, который был задан при установке PostgreSQL.</p>\r\n<p>После успешного логина нам откроется содержимое сервера:</p>\r\n<img src=\"pics/pgadmin4.png\" alt=\"Базы данных в pgAdmin\">\r\n<p>В частности, в узле <span class=\"b\">Databases</span> мы можем увидеть все имеющиеся базы данных. По умолчанию здесь есть только одна база данных - postgres.</p>\r\n<p>Также в правой части мы можем увидеть узел <span class=\"b\">Login/Group Roles</span>, который предназначен для управления пользователями и их ролями.</p>\r\n<p>И третий узел - <span class=\"b\">Tablespaces</span> позволяет управлять местом хранения файлов баз данных.</p>\r\n<p>Теперь создадим свою базу данных. Для этого нажмем правой кнопкой мыши на узел <span class=\"b\">Databases</span>. И далее в контекстном меню \r\nвыберем <span class=\"b\">Create</span>-&gt;<span class=\"b\">Database...</span></p>\r\n<img src=\"pics/pgadmin5.png\" alt=\"Создание базы данных в pgAdmin\">\r\n<p>После этого нам отобразится окно для создания базы данных. Введем название для БД, например, <span class=\"b\">test1</span> и нажмем на кнопку \r\n\"Save\":</p>\r\n<img src=\"pics/pgadmin6.png\" alt=\"Создание базы данных в PostgreSQL через pgAdmin\">\r\n<p>После этого в древовидном меню слева отобразится содержимое созданной базы данных test1:</p>\r\n<img src=\"pics/pgadmin7.png\" alt=\"Администрирование в PostgreSQL через pgAdmin\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"1.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"1.3.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/1.3.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 15.03.2018", "title": "Запросы SQL в pgAdmin", "text": "\n Запросы SQL в pgAdmin Последнее обновление: 15.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Как правило, работа с базой данных осуществляется с помощью специального языка запросов - SQL. Рассмотрим, как выполнять простейшие SQL-запросы к базе данных \r\nв pgAdmin. \r\n К примеру, возьмем базу данных test1, которая была создана в прошлой теме (или создадим новую) и добавим в нее таблицу и некоторые начальные данные. \r\nДля этого нажмем в правой части окна pgAdmin на базу данных правой кнопкой мыши и в появившемся контекстном меню выберем пункт  Query Tool : \r\n \r\n После этого в центральной части программы откроется поле для ввода кода SQL. Введем следующий набор выражений: \r\n \r\nCREATE TABLE users\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Name CHARACTER VARYING(30),\r\n\tAge INTEGER\r\n);\r\nINSERT INTO users (Name, Age) VALUES ('Tom', 33);\r\n \r\n \r\n Фактически весь код разбивается на две части. Первая часть - инструкция  CREATE TABLE , которая создает таблицу users с тремя столбцами \r\nId, Name и Age. И вторая часть - инструкция  INSERT , которая добавляет в строку одну таблицу. \r\n Чтобы выполнить данные инструкции, нажмем над кодом в панели инструментов на значок молнии. И после этого в выбранную базу данных (test1) \r\nбудет добавлена таблица users, в которую будет добавлена одна строка. \r\n Впоследствии подобным образом будет выполняться любой другой код SQL к базе данных. Также выбирается нужная база данных, выбирается параметр Query Tool, \r\nи далее в поле ввода вводится код SQL, который затем выполняется. \r\n Следует отметить, что для каждой таблицы определяется схема. По умолчанию это схема \"public\". Поэтому чтобы найти таблицу, нам надо обратиться к \r\nузлу базы данных, раскрыть его, далее выбрать подузел  Schemas , в нем подузел \r\n public  (название схема), и далее в нем подузел  Tables , \r\nкоторый представляет все таблицы, ассоциированные со схемой public: \r\n \r\n Теперь получим данные из таблицы, которые были добавлены при ее создании. Для этого выполним следующий код: \r\n \r\nSELECT * FROM users\r\n \r\n И внизу программы в поле Data Output мы увидим в табличном представлении те данные, которые ранее были добавлены. \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Запросы SQL в pgAdmin</h2><div class=\"date\">Последнее обновление: 15.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Как правило, работа с базой данных осуществляется с помощью специального языка запросов - SQL. Рассмотрим, как выполнять простейшие SQL-запросы к базе данных \r\nв pgAdmin.</p>\r\n<p>К примеру, возьмем базу данных test1, которая была создана в прошлой теме (или создадим новую) и добавим в нее таблицу и некоторые начальные данные. \r\nДля этого нажмем в правой части окна pgAdmin на базу данных правой кнопкой мыши и в появившемся контекстном меню выберем пункт <span class=\"b\">Query Tool</span>:</p>\r\n<img src=\"pics/pgadmin8.png\" alt=\"Query Tool in pgAdmin\">\r\n<p>После этого в центральной части программы откроется поле для ввода кода SQL. Введем следующий набор выражений:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE users\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Name CHARACTER VARYING(30),\r\n\tAge INTEGER\r\n);\r\nINSERT INTO users (Name, Age) VALUES ('Tom', 33);\r\n</pre>\r\n<img src=\"pics/pgadmin9.png\" alt=\"Создание таблицы в pgAdmin\">\r\n<p>Фактически весь код разбивается на две части. Первая часть - инструкция <code>CREATE TABLE</code>, которая создает таблицу users с тремя столбцами \r\nId, Name и Age. И вторая часть - инструкция <code>INSERT</code>, которая добавляет в строку одну таблицу.</p>\r\n<p>Чтобы выполнить данные инструкции, нажмем над кодом в панели инструментов на значок молнии. И после этого в выбранную базу данных (test1) \r\nбудет добавлена таблица users, в которую будет добавлена одна строка.</p>\r\n<p>Впоследствии подобным образом будет выполняться любой другой код SQL к базе данных. Также выбирается нужная база данных, выбирается параметр Query Tool, \r\nи далее в поле ввода вводится код SQL, который затем выполняется.</p>\r\n<p>Следует отметить, что для каждой таблицы определяется схема. По умолчанию это схема \"public\". Поэтому чтобы найти таблицу, нам надо обратиться к \r\nузлу базы данных, раскрыть его, далее выбрать подузел <span class=\"b\">Schemas</span>, в нем подузел \r\n<span class=\"b\">public</span> (название схема), и далее в нем подузел <span class=\"b\">Tables</span>, \r\nкоторый представляет все таблицы, ассоциированные со схемой public:</p>\r\n<img src=\"pics/pgadmin10.png\" alt=\"таблицы в pgAdmin\">\r\n<p>Теперь получим данные из таблицы, которые были добавлены при ее создании. Для этого выполним следующий код:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM users\r\n</pre>\r\n<p>И внизу программы в поле Data Output мы увидим в табличном представлении те данные, которые ранее были добавлены.</p>\r\n<img src=\"pics/pgadmin11.png\" alt=\"SQL запросы в pgAdmin\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"1.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"1.4.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/1.4.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 15.03.2018", "title": "Консольный клиент psql", "text": "\n Консольный клиент psql Последнее обновление: 15.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Консольный клиент psql представляет еще один способ взаимодействия с сервером PostgreSQL. Данная программа также, как и pgAdmin, позволяет выполнять команды языка SQL. \r\n \r\n Запустим psql. Программа предложит ввести название сервера, базы данных, порта и пользователя. Эти пункты можно прощелкать, так как для них будут использоваться \r\nзначения по умолчанию (для сервера - localhost, для базы данных - postgres, для порта - 5432, в качестве пользователя - суперпользователь postres). \r\nДалее надо будет ввести пароль для пользователя (по умолчанию пользователя postgres): \r\n \r\n И после удачного подключения можно будет отправлять серверу команды через psql. \r\n Теперь создадим базу данных с помощью следующей команды языка SQL: \r\n create database test2; \r\n Для создания базы данных применяется команда  create database , после которой указывается название бд. \r\nТо есть в данном случае название бд - \"test2\". Причем команда завершается точкой с запятой. \r\n Далее подключимся к этой базе данных для осуществления с ней взаимодействия. Для этого применяется команда  \\c  (сокращение от connect), \r\nпосле которой указывается имя базы данных: \r\n \\c test2 \r\n Затем создадим в этой базе данных таблицу с помощью команды: \r\n create table users (Id serial primary key, Name character varying(30), Age integer); \r\n Данная команда создает таблицу users, в которой будет три столбца - Id, Name и Age. \r\n \r\n После этого мы можем добавлять и получать данные из выше созданной таблицы. Вначале добавим в таблицу одну строку с помощью следующей команды: \r\n insert into users (Name, Age) values ('Tom', 33); \r\n И в конце получим добавленные данные: \r\n select * from users; \r\n \r\n Стоит отметить, что по умолчанию консоль в Windows поддерживает кодировку CP866, тогда как базы данных могут работать совсем с другой кодировкой, \r\nнапример, 1251. И даже сам клиент psql выводит нам соответствующие сообщения. Кроме того, при получении данных, при выводе информации о базах данных, таблицы и т.д. \r\nнекоторая информация может отображаться некорректно. В этом случае перед запуском psql надо установить нужную кодировку и затем из консоли запустить программу psql. \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Консольный клиент psql</h2><div class=\"date\">Последнее обновление: 15.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Консольный клиент psql представляет еще один способ взаимодействия с сервером PostgreSQL. Данная программа также, как и pgAdmin, позволяет выполнять команды языка SQL.</p>\r\n<img src=\"pics/psql1.png\" alt=\"Консольный клиент psql для работы с PostgreSQL\">\r\n<p>Запустим psql. Программа предложит ввести название сервера, базы данных, порта и пользователя. Эти пункты можно прощелкать, так как для них будут использоваться \r\nзначения по умолчанию (для сервера - localhost, для базы данных - postgres, для порта - 5432, в качестве пользователя - суперпользователь postres). \r\nДалее надо будет ввести пароль для пользователя (по умолчанию пользователя postgres):</p>\r\n<img src=\"pics/psql2.png\" alt=\"Консольный клиент psql\">\r\n<p>И после удачного подключения можно будет отправлять серверу команды через psql.</p>\r\n<p>Теперь создадим базу данных с помощью следующей команды языка SQL:</p>\r\n<div class=\"console\"><pre class=\"consoletext\">create database test2;</pre></div>\r\n<p>Для создания базы данных применяется команда <span class=\"b\">create database</span>, после которой указывается название бд. \r\nТо есть в данном случае название бд - \"test2\". Причем команда завершается точкой с запятой.</p>\r\n<p>Далее подключимся к этой базе данных для осуществления с ней взаимодействия. Для этого применяется команда <code>\\c</code> (сокращение от connect), \r\nпосле которой указывается имя базы данных:</p>\r\n<div class=\"console\"><pre class=\"consoletext\">\\c test2</pre></div>\r\n<p>Затем создадим в этой базе данных таблицу с помощью команды:</p>\r\n<div class=\"console\"><pre class=\"consoletext\">create table users (Id serial primary key, Name character varying(30), Age integer);</pre></div>\r\n<p>Данная команда создает таблицу users, в которой будет три столбца - Id, Name и Age.</p>\r\n<img src=\"pics/psql3.png\" alt=\"create database and tables in psql\">\r\n<p>После этого мы можем добавлять и получать данные из выше созданной таблицы. Вначале добавим в таблицу одну строку с помощью следующей команды:</p>\r\n<div class=\"console\"><pre class=\"consoletext\">insert into users (Name, Age) values ('Tom', 33);</pre></div>\r\n<p>И в конце получим добавленные данные:</p>\r\n<div class=\"console\"><pre class=\"consoletext\">select * from users;</pre></div>\r\n<img src=\"pics/psql4.png\" alt=\"insert and select in psql\">\r\n<p>Стоит отметить, что по умолчанию консоль в Windows поддерживает кодировку CP866, тогда как базы данных могут работать совсем с другой кодировкой, \r\nнапример, 1251. И даже сам клиент psql выводит нам соответствующие сообщения. Кроме того, при получении данных, при выводе информации о базах данных, таблицы и т.д. \r\nнекоторая информация может отображаться некорректно. В этом случае перед запуском psql надо установить нужную кодировку и затем из консоли запустить программу psql.</p>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"1.3.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.1.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 17.03.2018", "title": "Создание и удаление базы данных", "text": "\n Определение структуры данных Создание и удаление базы данных Последнее обновление: 17.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Создание базы данных \r\n Для создания базы данных используется команда  CREATE DATABASE , после которой указывается название базы данных. \r\n Для выполнения запросов будем использовать графический клиент pgAdmin, хотя также можно использовать консольный клиент psql. \r\n Чтобы создать новую базу, данных откроем  pgAdmin . В левой части программы выберем какую-нибудь базу данных, например, \r\nстандартную бд postgres, и нажмем на нее правой кнопкой мыши. \r\n \r\n В появившемся меню выберем пункт  Query Tool... , и в центральной части программы откроется поле для ввода кода SQL. \r\nВ это поле введем следующий код: \r\n CREATE DATABASE usersdb; \r\n \r\n Для выполнения кода нажмем на значок молнии, и после этого будет создана база данных usersdb. \r\n Чтобы увидеть нашу базу данных, нажмем в левой части на узел  Databases  правой кнопкой мыши и в контекстном меню выберем \r\n Refresh... : \r\n \r\n Произойдет обновление, и мы увидем созданную базу данных. \r\n \r\n По умолчанию база является неактивной, поэтому ее значок имеет серый цвет. Но чтобы к ней подключиться, достаточно нажать на нее и раскрыть ее узел. \r\n Удаление базы данных \r\n Для удаления базы данных применяется команда  DROP DATABASE , после которой указывается название базы данных. \r\n Удаляемая база данных должна быть неактивной, то есть подключение к ней должно быть закрыта. \r\n Например, удаление базы данных usersdb: \r\n DROP DATABASE usersdb; \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Определение структуры данных</h1><h2>Создание и удаление базы данных</h2><div class=\"date\">Последнее обновление: 17.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<h3>Создание базы данных</h3>\r\n<p>Для создания базы данных используется команда <code>CREATE DATABASE</code>, после которой указывается название базы данных.</p>\r\n<p>Для выполнения запросов будем использовать графический клиент pgAdmin, хотя также можно использовать консольный клиент psql.</p>\r\n<p>Чтобы создать новую базу, данных откроем <span class=\"b\">pgAdmin</span>. В левой части программы выберем какую-нибудь базу данных, например, \r\nстандартную бд postgres, и нажмем на нее правой кнопкой мыши.</p>\r\n<img src=\"pics/2.1.png\" alt=\"Создание базы данных в PostgreSQL и pgAdmin\">\r\n<p>В появившемся меню выберем пункт <span class=\"b\">Query Tool...</span>, и в центральной части программы откроется поле для ввода кода SQL. \r\nВ это поле введем следующий код:</p>\r\n<pre class=\"brush:sql;\">CREATE DATABASE usersdb;</pre>\r\n<img src=\"pics/2.2.png\" alt=\"CREATE DATABASE в PostgreSQL\">\r\n<p>Для выполнения кода нажмем на значок молнии, и после этого будет создана база данных usersdb.</p>\r\n<p>Чтобы увидеть нашу базу данных, нажмем в левой части на узел <span class=\"b\">Databases</span> правой кнопкой мыши и в контекстном меню выберем \r\n<span class=\"b\">Refresh...</span>:</p>\r\n<img src=\"pics/2.3.png\">\r\n<p>Произойдет обновление, и мы увидем созданную базу данных.</p>\r\n<img src=\"pics/2.4.png\" alt=\"Промотр баз данных в pgAdmin\">\r\n<p>По умолчанию база является неактивной, поэтому ее значок имеет серый цвет. Но чтобы к ней подключиться, достаточно нажать на нее и раскрыть ее узел.</p>\r\n<h3>Удаление базы данных</h3>\r\n<p>Для удаления базы данных применяется команда <code>DROP DATABASE</code>, после которой указывается название базы данных.</p>\r\n<p>Удаляемая база данных должна быть неактивной, то есть подключение к ней должно быть закрыта.</p>\r\n<p>Например, удаление базы данных usersdb:</p>\r\n<pre class=\"brush:sql;\">DROP DATABASE usersdb;</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"1.4.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 17.03.2018", "title": "Создание и удаление таблиц", "text": "\n Создание и удаление таблиц Последнее обновление: 17.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для создания таблиц применяется команда  CREATE TABLE , после которой указывается название таблицы. \r\nТакже с этой командой можно использовать ряд операторов, которые определяют столбцы таблицы и их атрибуты. \r\nОбщий синтаксис создания таблицы выглядит следующим образом: \r\n \r\nCREATE TABLE название_таблицы\r\n(название_столбца1 тип_данных атрибуты_столбца1, \r\n название_столбца2 тип_данных атрибуты_столбца2,\r\n ................................................\r\n название_столбцаN тип_данных атрибуты_столбцаN,\r\n атрибуты_таблицы\r\n);\r\n \r\n После названия таблицы в скобках перечисляется спецификация для всех столбцов. Причем для каждого столбца надо указывается название и тип данных, который он будет \r\nпредставлять. Тип данных определяет, какие данные (числа, строки и т.д.) может содержать столбец. \r\n Например, создадим таблицу в базе данных через pgAdmin. Для этого вначале выберем в pgAdmin целевую базу данных, нажмем на нее правой кнопкой мыши и \r\nв контекстном меню выберем пункт  Query Tool... : \r\n \r\n После этого откроется поле для ввода кода на SQL. Причем таблица будет создаваться именно для той базы данных, для которой мы откровыем это поле для ввода SQL. \r\n Далее в открывшееся в центральной части программы поле введем следующий набор выражений: \r\n \r\nCREATE TABLE customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n\tEmail CHARACTER VARYING(30),\r\n\tAge INTEGER\r\n);\r\n \r\n В данном случае в таблице Customers определяются пять столбцов: Id, FirstName, LastName, Age, Email. \r\nПервый столбец - Id представляет идентификатор клиента, он служит первичным ключом и поэтому имеет тип  SERIAL . Фактически данный столбец будет хранить числовое значение 1, 2, 3 и т.д., \r\nкоторое для каждой новой строки будет автоматически увеличиваться на единицу. \r\n Следующие три столбца представляют имя, фамилию клиента и его электронный адрес и имеют тип  CHARACTER VARYING(30) , \r\nто есть представляют строку длиной не более 30 символов. \r\n Последний столбец - Age представляет возраст пользователя и имеет тип  INTEGER , то есть хранит числа. \r\n \r\n И после выполнения этой команды в выбранную базу данных будет добавлена таблица customers. \r\n Удаление таблиц \r\n Для удаления таблиц используется команда  DROP TABLE , которая имеет следующий синтаксис: \r\n DROP TABLE table1 [, table2, ...]; \r\n Например, удаление таблицы customers: \r\n DROP TABLE customers; \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Создание и удаление таблиц</h2><div class=\"date\">Последнее обновление: 17.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для создания таблиц применяется команда <span class=\"b\">CREATE TABLE</span>, после которой указывается название таблицы. \r\nТакже с этой командой можно использовать ряд операторов, которые определяют столбцы таблицы и их атрибуты. \r\nОбщий синтаксис создания таблицы выглядит следующим образом:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE название_таблицы\r\n(название_столбца1 тип_данных атрибуты_столбца1, \r\n название_столбца2 тип_данных атрибуты_столбца2,\r\n ................................................\r\n название_столбцаN тип_данных атрибуты_столбцаN,\r\n атрибуты_таблицы\r\n);\r\n</pre>\r\n<p>После названия таблицы в скобках перечисляется спецификация для всех столбцов. Причем для каждого столбца надо указывается название и тип данных, который он будет \r\nпредставлять. Тип данных определяет, какие данные (числа, строки и т.д.) может содержать столбец.</p>\r\n<p>Например, создадим таблицу в базе данных через pgAdmin. Для этого вначале выберем в pgAdmin целевую базу данных, нажмем на нее правой кнопкой мыши и \r\nв контекстном меню выберем пункт <span class=\"b\">Query Tool...</span>:</p>\r\n<img src=\"pics/2.5.png\" alt=\"Создание таблицы в базе данных PostgreSQL\">\r\n<p>После этого откроется поле для ввода кода на SQL. Причем таблица будет создаваться именно для той базы данных, для которой мы откровыем это поле для ввода SQL.</p>\r\n<p>Далее в открывшееся в центральной части программы поле введем следующий набор выражений:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n\tEmail CHARACTER VARYING(30),\r\n\tAge INTEGER\r\n);\r\n</pre>\r\n<p>В данном случае в таблице Customers определяются пять столбцов: Id, FirstName, LastName, Age, Email. \r\nПервый столбец - Id представляет идентификатор клиента, он служит первичным ключом и поэтому имеет тип <span class=\"b\">SERIAL</span>. Фактически данный столбец будет хранить числовое значение 1, 2, 3 и т.д., \r\nкоторое для каждой новой строки будет автоматически увеличиваться на единицу.</p>\r\n<p>Следующие три столбца представляют имя, фамилию клиента и его электронный адрес и имеют тип <span class=\"b\">CHARACTER VARYING(30)</span>, \r\nто есть представляют строку длиной не более 30 символов.</p>\r\n<p>Последний столбец - Age представляет возраст пользователя и имеет тип <span class=\"b\">INTEGER</span>, то есть хранит числа.</p>\r\n<img src=\"pics/2.6.png\" alt=\"Создание таблицы в pgAdmin\">\r\n<p>И после выполнения этой команды в выбранную базу данных будет добавлена таблица customers.</p>\r\n<h3>Удаление таблиц</h3>\r\n<p>Для удаления таблиц используется команда <span class=\"b\">DROP TABLE</span>, которая имеет следующий синтаксис:</p>\r\n<pre class=\"brush:sql;\">DROP TABLE table1 [, table2, ...];</pre>\r\n<p>Например, удаление таблицы customers:</p>\r\n<pre class=\"brush:sql;\">DROP TABLE customers;</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.3.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.3.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 17.03.2018", "title": "Типы данных в PostgreSQL", "text": "\n Типы данных в PostgreSQL Последнее обновление: 17.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n При определении таблицы для всех ее столбцов необходимо указать тип данных. Тип данных определяет диапазон значений, которые могут храниться в столбце, \r\nсколько они будут занимать места в памяти. PostgreSQL поддерживает богатую палитру различных типов данных, среди которые условно можно разделить на подгруппы: числовые, символьные, \r\nлогические, дата и время, бинарные и ряд других. \r\n Числовые типы данных \r\n \r\n serial : представляет автоинкрементирующееся числовое значение, которое занимает 4 байта и может хранить \r\nчисла от 1 до 2147483647. Значение данного типа образуется путем автоинкремента значения предыдущей строки.  Поэтому, как правило, данный тип используется для определения идентификаторов строки. \r\n smallserial : представляет автоинкрементирующееся числовое значение, которое занимает 2 байта и может хранить \r\nчисла от 1 до 32767. Аналог типа  serial  для небольших чисел. \r\n bigserial : представляет автоинкрементирующееся числовое значение, которое занимает 8 байт и может хранить \r\nчисла от 1 до 9223372036854775807. Аналог типа  serial  для больших чисел. \r\n\r\n smallint : хранит числа от -32768 до +32767. Занимает 2 байта. Имеет псевдоним  int2 . \r\n integer : хранит числа от -2147483648 до +2147483647. Занимает 4 байта. Имеет псевдонимы  int  и  int4 . \r\n bigint : хранит числа от -9223372036854775808 до +9223372036854775807. Занимает 8 байт. Имеет псевдоним  int8 . \r\n\r\n numeric : хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков после запятой. \r\n Данный тип может принимать два параметра precision и scale:  numeric(precision, scale) . \r\n Параметр  precision  указывает на максимальное количество цифр, которые может хранить число. \r\n Параметр  scale  представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0. \r\n Например, для числа  23.5141  precision равно 6, а scale - 4. \r\n decimal : хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков \r\nв дробной части. То же самое, что и  numeric . \r\n real : хранит числа с плавающей точкой из диапазона от 1E-37 до 1E+37. Занимает 4 байта. Имеет псевдоним \r\n float4 . \r\n double precision : хранит числа с плавающей точкой из диапазона от 1E-307 до 1E+308. Занимает 8 байт. Имеет псевдоним \r\n float8 . \r\n \r\n Примеры использования: \r\n \r\nId SERIAL,\r\nTotalWeight NUMERIC(9,2),\r\nAge INTEGER,\r\nSurplus REAL\r\n \r\n Типы для работы с валютой (денежными единицами) \r\n Для работы с денежными единицами определен тип  money , который может принимать значения в диапазоне от \r\n-92233720368547758.08 до +92233720368547758.07 и занимает 8 байт. \r\n Символьные типы \r\n \r\n character(n) : представляет строку из фиксированного количества символов. С помощью параметра задается задается количетво \r\nсимволов в строке. Имеет псевдоним  char(n) . \r\n character varying(n) : представляет строку из фиксированного количества символов. С помощью параметра задается задается количетво \r\nсимволов в строке. Имеет псевдоним  varchar(n) . \r\n text : представляет текст произвольной длины. \r\n \r\n Бинарные данные \r\n Для хранения бинарных данных определен тип  bytea . Он хранит данные в виде бинарных строк, которые представляют последовательность октетов или байт. \r\n Типы для работы с датами и временем \r\n \r\n timestamp : хранит дату и время. Занимает 8 байт. Для дат самое нижнее значение - 4713 г до н.э., самое верхнее значение - \r\n294276 г н.э. \r\n timestamp with time zone : то же самое, что и  timestamp , только добавляет данные о часовом поясе. \r\n date : представляет дату от 4713 г. до н.э. до 5874897 г н.э. Занимает 4 байта. \r\n time : хранит время с точностью до 1 микросекунды без указания часового пояса. Принимает значения от 00:00:00 до 24:00:00. Занимает 8 байт. \r\n time with time zone : хранит время с точностью до 1 микросекунды с указанием часового пояса. Принимает значения от 00:00:00+1459 до 24:00:00-1459. Занимает 12 байт. \r\n interval : представляет временной интервал. Занимает 16 байт. \r\n \r\n Распространенные форматы дат: \r\n \r\n yyyy-mm-dd  -  1999-01-08 \r\n Month dd, yyyy  -  January 8, 1999 \r\n mm/dd/yyyy  -  1/8/1999 \r\n \r\n Распространенные форматы времени: \r\n \r\n hh:mi  -  13:21 \r\n hh:mi am/pm  -  1:21 pm \r\n hh:mi:ss  -  1:21:34 \r\n \r\n Логический тип \r\n Тип  boolean  может хранить одно из двух значений: true или false. \r\n Вместо  true  можно указывать следующие значения: TRUE, 't', 'true', 'y', 'yes', 'on', '1'. \r\n Вместо  false  можно указывать следующие значения: FALSE, 'f', 'false', 'n', 'no', 'off', '0'. \r\n Типы для представления интернет-адресов \r\n \r\n cidr : интернет-адрес в формате IPv4 и IPv6. Например,  192.168.0.1 . Занимает от 7 до 19 байт. \r\n inet : интернет-адрес в формате  cidr/y , где  cidr  это адрес в формате IPv4 или IPv6, а  /y  - \r\nколичество бит в адресе (если этот параметр не указан, то используется 34 для IPv4, 128 для IPv6). Например,  192.168.0.1/24  или  2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128 . Занимает от 7 до 19 байт. \r\n macaddr : хранит MAC-адрес. Занимает 6 байт. \r\n macaddr8 : хранит MAC-адрес в формате EUI-64. Занимает 8 байт. \r\n \r\n Геометрические типы \r\n \r\n point : представляет точку на плоскости в формате  (x,y) . Занимает 16 байт. \r\n line : представляет линию неопределенной длины в формате  {A,B,C} . Занимает 32 байта. \r\n lseg : представляет отрезок в формате  ((x1,y1),(x2,y2)) . Занимает 32 байта. \r\n box : представляет прямоугольник в формате  ((x1,y1),(x2,y2)) . Занимает 32 байта. \r\n path : представляет набор содиненных точек. В формате  ((x1,y1),...)  путь является закрытым (первая и последняя точка соединяются линией) \r\nи фактически представляет многоугольник. В формате  [(x1,y1),...]  путь является открытым Занимает 16+16n байт. \r\n \r\n polygon : представляет многоугольник в формате  ((x1,y1),...) . Занимает 40+16n байт. \r\n circle : представляет окружность в формате  <(x,y),r> . Занимает 24 байта. \r\n \r\n Остальные типы данных \r\n \r\n json : хранит данные json в текстовом виде. \r\n jsonb : хранит данные json в бинарном формате. \r\n uuid : хранит универсальный уникальный идентификатор (UUID), например,  a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 . Занимает 32 байта. \r\n xml : хранит даные в формате XML. \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Типы данных в PostgreSQL</h2><div class=\"date\">Последнее обновление: 17.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>При определении таблицы для всех ее столбцов необходимо указать тип данных. Тип данных определяет диапазон значений, которые могут храниться в столбце, \r\nсколько они будут занимать места в памяти. PostgreSQL поддерживает богатую палитру различных типов данных, среди которые условно можно разделить на подгруппы: числовые, символьные, \r\nлогические, дата и время, бинарные и ряд других.</p>\r\n<h3>Числовые типы данных</h3>\r\n<ul>\r\n<li><p><span class=\"b\">serial</span>: представляет автоинкрементирующееся числовое значение, которое занимает 4 байта и может хранить \r\nчисла от 1 до 2147483647. Значение данного типа образуется путем автоинкремента значения предыдущей строки.  Поэтому, как правило, данный тип используется для определения идентификаторов строки.</p></li>\r\n<li><p><span class=\"b\">smallserial</span>: представляет автоинкрементирующееся числовое значение, которое занимает 2 байта и может хранить \r\nчисла от 1 до 32767. Аналог типа <code>serial</code> для небольших чисел.</p></li>\r\n<li><p><span class=\"b\">bigserial</span>: представляет автоинкрементирующееся числовое значение, которое занимает 8 байт и может хранить \r\nчисла от 1 до 9223372036854775807. Аналог типа <code>serial</code> для больших чисел.</p></li>\r\n\r\n<li><p><span class=\"b\">smallint</span>: хранит числа от -32768 до +32767. Занимает 2 байта. Имеет псевдоним <span class=\"b\">int2</span>.</p></li>\r\n<li><p><span class=\"b\">integer</span>: хранит числа от -2147483648 до +2147483647. Занимает 4 байта. Имеет псевдонимы <span class=\"b\">int</span> и <span class=\"b\">int4</span>.</p></li>\r\n<li><p><span class=\"b\">bigint</span>: хранит числа от -9223372036854775808 до +9223372036854775807. Занимает 8 байт. Имеет псевдоним <span class=\"b\">int8</span>.</p></li>\r\n\r\n<li><p><span class=\"b\">numeric</span>: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков после запятой.</p>\r\n<p>Данный тип может принимать два параметра precision и scale: <code>numeric(precision, scale)</code>.</p>\r\n<p>Параметр <code>precision</code> указывает на максимальное количество цифр, которые может хранить число.</p>\r\n<p>Параметр <code>scale</code> представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.</p>\r\n<p>Например, для числа <code>23.5141</code> precision равно 6, а scale - 4.</p></li>\r\n<li><p><span class=\"b\">decimal</span>: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков \r\nв дробной части. То же самое, что и <code>numeric</code>.</p></li>\r\n<li><p><span class=\"b\">real</span>: хранит числа с плавающей точкой из диапазона от 1E-37 до 1E+37. Занимает 4 байта. Имеет псевдоним \r\n<code>float4</code>.</p></li>\r\n<li><p><span class=\"b\">double precision</span>: хранит числа с плавающей точкой из диапазона от 1E-307 до 1E+308. Занимает 8 байт. Имеет псевдоним \r\n<code>float8</code>.</p></li>\r\n</ul>\r\n<p>Примеры использования:</p>\r\n<pre class=\"brush:sql;\">\r\nId SERIAL,\r\nTotalWeight NUMERIC(9,2),\r\nAge INTEGER,\r\nSurplus REAL\r\n</pre>\r\n<h3>Типы для работы с валютой (денежными единицами)</h3>\r\n<p>Для работы с денежными единицами определен тип <span class=\"b\">money</span>, который может принимать значения в диапазоне от \r\n-92233720368547758.08 до +92233720368547758.07 и занимает 8 байт.</p>\r\n<h3>Символьные типы</h3>\r\n<ul>\r\n<li><p><span class=\"b\">character(n)</span>: представляет строку из фиксированного количества символов. С помощью параметра задается задается количетво \r\nсимволов в строке. Имеет псевдоним <span class=\"b\">char(n)</span>.</p></li>\r\n<li><p><span class=\"b\">character varying(n)</span>: представляет строку из фиксированного количества символов. С помощью параметра задается задается количетво \r\nсимволов в строке. Имеет псевдоним <span class=\"b\">varchar(n)</span>.</p></li>\r\n<li><p><span class=\"b\">text</span>: представляет текст произвольной длины.</p></li>\r\n</ul>\r\n<h3>Бинарные данные</h3>\r\n<p>Для хранения бинарных данных определен тип <span class=\"b\">bytea</span>. Он хранит данные в виде бинарных строк, которые представляют последовательность октетов или байт.</p>\r\n<h3>Типы для работы с датами и временем</h3>\r\n<ul>\r\n<li><p><span class=\"b\">timestamp</span>: хранит дату и время. Занимает 8 байт. Для дат самое нижнее значение - 4713 г до н.э., самое верхнее значение - \r\n294276 г н.э.</p></li>\r\n<li><p><span class=\"b\">timestamp with time zone</span>: то же самое, что и <code>timestamp</code>, только добавляет данные о часовом поясе.</p></li>\r\n<li><p><span class=\"b\">date</span>: представляет дату от 4713 г. до н.э. до 5874897 г н.э. Занимает 4 байта.</p></li>\r\n<li><p><span class=\"b\">time</span>: хранит время с точностью до 1 микросекунды без указания часового пояса. Принимает значения от 00:00:00 до 24:00:00. Занимает 8 байт.</p></li>\r\n<li><p><span class=\"b\">time with time zone</span>: хранит время с точностью до 1 микросекунды с указанием часового пояса. Принимает значения от 00:00:00+1459 до 24:00:00-1459. Занимает 12 байт.</p></li>\r\n<li><p><span class=\"b\">interval</span>: представляет временной интервал. Занимает 16 байт.</p></li>\r\n</ul>\r\n<p>Распространенные форматы дат:</p>\r\n<ul>\r\n<li><p><code>yyyy-mm-dd</code> - <code>1999-01-08</code></p></li>\r\n<li><p><code>Month dd, yyyy</code> - <code>January 8, 1999</code></p></li>\r\n<li><p><code>mm/dd/yyyy</code> - <code>1/8/1999</code></p></li>\r\n</ul>\r\n<p>Распространенные форматы времени:</p>\r\n<ul>\r\n<li><p><code>hh:mi</code> - <code>13:21</code></p></li>\r\n<li><p><code>hh:mi am/pm</code> - <code>1:21 pm</code></p></li>\r\n<li><p><code>hh:mi:ss</code> - <code>1:21:34</code></p></li>\r\n</ul>\r\n<h3>Логический тип</h3>\r\n<p>Тип <span class=\"b\">boolean</span> может хранить одно из двух значений: true или false.</p>\r\n<p>Вместо <code>true</code> можно указывать следующие значения: TRUE, 't', 'true', 'y', 'yes', 'on', '1'.</p>\r\n<p>Вместо <code>false</code> можно указывать следующие значения: FALSE, 'f', 'false', 'n', 'no', 'off', '0'.</p>\r\n<h3>Типы для представления интернет-адресов</h3>\r\n<ul>\r\n<li><p><span class=\"b\">cidr</span>: интернет-адрес в формате IPv4 и IPv6. Например, <code>192.168.0.1</code>. Занимает от 7 до 19 байт.</p></li>\r\n<li><p><span class=\"b\">inet</span>: интернет-адрес в формате <code>cidr/y</code>, где <code>cidr</code> это адрес в формате IPv4 или IPv6, а <code>/y</code> - \r\nколичество бит в адресе (если этот параметр не указан, то используется 34 для IPv4, 128 для IPv6). Например, <code>192.168.0.1/24</code> или <code>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</code>. Занимает от 7 до 19 байт.</p></li>\r\n<li><p><span class=\"b\">macaddr</span>: хранит MAC-адрес. Занимает 6 байт.</p></li>\r\n<li><p><span class=\"b\">macaddr8</span>: хранит MAC-адрес в формате EUI-64. Занимает 8 байт.</p></li>\r\n</ul>\r\n<h3>Геометрические типы</h3>\r\n<ul>\r\n<li><p><span class=\"b\">point</span>: представляет точку на плоскости в формате <code>(x,y)</code>. Занимает 16 байт.</p></li>\r\n<li><p><span class=\"b\">line</span>: представляет линию неопределенной длины в формате <code>{A,B,C}</code>. Занимает 32 байта.</p></li>\r\n<li><p><span class=\"b\">lseg</span>: представляет отрезок в формате <code>((x1,y1),(x2,y2))</code>. Занимает 32 байта.</p></li>\r\n<li><p><span class=\"b\">box</span>: представляет прямоугольник в формате <code>((x1,y1),(x2,y2))</code>. Занимает 32 байта.</p></li>\r\n<li><p><span class=\"b\">path</span>: представляет набор содиненных точек. В формате <code>((x1,y1),...)</code> путь является закрытым (первая и последняя точка соединяются линией) \r\nи фактически представляет многоугольник. В формате <code>[(x1,y1),...]</code> путь является открытым Занимает 16+16n байт.</p>\r\n</li>\r\n<li><p><span class=\"b\">polygon</span>: представляет многоугольник в формате <code>((x1,y1),...)</code>. Занимает 40+16n байт.</p></li>\r\n<li><p><span class=\"b\">circle</span>: представляет окружность в формате <code>&lt;(x,y),r&gt;</code>. Занимает 24 байта.</p></li>\r\n</ul>\r\n<h3>Остальные типы данных</h3>\r\n<ul>\r\n<li><p><span class=\"b\">json</span>: хранит данные json в текстовом виде.</p></li>\r\n<li><p><span class=\"b\">jsonb</span>: хранит данные json в бинарном формате.</p></li>\r\n<li><p><span class=\"b\">uuid</span>: хранит универсальный уникальный идентификатор (UUID), например, <code>a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11</code>. Занимает 32 байта.</p></li>\r\n<li><p><span class=\"b\">xml</span>: хранит даные в формате XML.</p></li>\r\n</ul>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.4.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.4.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.10.2020", "title": "Ограничения столбцов и таблиц", "text": "\n Ограничения столбцов и таблиц Последнее обновление: 23.10.2020 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n При определении таблиц и их столбцов в SQL мы можем использовать ряд атрибутов, которые накладывают определенные ограничения. \r\nРассмотрим эти атрибуты. \r\n PRIMARY KEY \r\n С помощью выражения  PRIMARY KEY  столбец можно сделать первичным ключом. \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n    Email CHARACTER VARYING(30),\r\n    Age INTEGER\r\n)\r\n \r\n Первичный ключ уникально идентифицирует строку в таблице. В качестве первичного ключа необязательно должны выступать столбцы с типом  SERIAL , они могут представлять \r\nлюбой другой тип. \r\n Установка первичного ключа на уровне таблицы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n    Email CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n    PRIMARY KEY(Id)\r\n);\r\n \r\n Первичный ключ может быть составным (compound key). Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать \r\nстроку в таблице. Например: \r\n \r\nCREATE TABLE OrderLines\r\n(\r\n\tOrderId INTEGER,\r\n\tProductId INTEGER,\r\n\tQuantity INTEGER,\r\n\tPrice MONEY,\r\n\tPRIMARY KEY(OrderId, ProductId)\r\n);\r\n \r\n Здесь поля OrderId и ProductId вместе выступают как составной первичный ключ. То есть в таблице OrderLines не может быть двух строк, где для обоих из этих полей одновременно \r\nбыли бы одни и те же значения. \r\n UNIQUE \r\n Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут  UNIQUE . \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30) UNIQUE,\r\n    Phone CHARACTER VARYING(30) UNIQUE,\r\n    Age INTEGER\r\n);\r\n \r\n В данном случае столбцы, которые представляют электронный адрес и телефон, будут иметь уникальные значения. И мы не сможем добавить в таблицу две строки, у которых \r\nзначения для этих столбцов будет совпадать. \r\n Также мы можем определить этот атрибут на уровне таблицы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n\tUNIQUE(Email, Phone)\r\n);\r\n \r\n Или так: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n\tUNIQUE(Email), \r\n\tUNIQUE(Phone)\r\n);\r\n \r\n NULL и NOT NULL \r\n Чтобы указать, может ли столбец принимать значение NULL, при определении столбца ему можно задать атрибут  NULL  или \r\n NOT NULL . Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение NULL. \r\nИсключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае по умолчанию столбец имеет значение NOT NULL. \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Age INTEGER\r\n);\r\n \r\n DEFAULT \r\n Атрибут  DEFAULT  определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет \r\nиспользоваться значение по умолчанию. \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Age INTEGER DEFAULT 18\r\n);\r\n \r\n Здесь для столбца Age предусмотрено значение по умолчанию 18. \r\n CHECK \r\n Ключевое слово  CHECK  задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после слова CHECK \r\nуказывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Age INTEGER DEFAULT 18 CHECK(Age >0 AND Age < 100),\r\n\tEmail CHARACTER VARYING(30) UNIQUE CHECK(Email !=''),\r\n    Phone CHARACTER VARYING(20) UNIQUE CHECK(Phone !='')\r\n);\r\n \r\n Здесь также указывается, что столбцы Email и Phone не могут иметь пустую строку в качестве значения (пустая строка  не  эквивалентна значению NULL). \r\n Для соединения условий используется ключевое слово  AND . Условия можно задать в виде операций сравнения больше (>), меньше (<), не равно (!=). \r\n Также с помощью CHECK можно создать ограничение в целом для таблицы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tAge INTEGER DEFAULT 18,\r\n\tFirstName CHARACTER VARYING(20),\r\n\tLastName CHARACTER VARYING(20),\r\n\tEmail CHARACTER VARYING(30) UNIQUE,\r\n\tPhone CHARACTER VARYING(20) UNIQUE,\r\n\tCHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))\r\n);\r\n \r\n Оператор CONSTRAINT. Установка имени ограничений. \r\n С помощью ключевого слова  CONSTRAINT  можно задать имя для ограничений. В качестве ограничений могут использоваться \r\nPRIMARY KEY, UNIQUE, CHECK. \r\n Имена ограничений можно задать на уровне столбцов. Они указываются после CONSTRAINT перед атрибутами: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,\r\n    Age INTEGER CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Email CHARACTER VARYING(30) CONSTRAINT customers_email_key UNIQUE,\r\n    Phone CHARACTER VARYING(20) CONSTRAINT customers_phone_key UNIQUE\r\n);\r\n \r\n\r\n В принципе необязательно задавать имена ограничений, при установке соответствующих атрибутов SQL Server автоматически определяет их имена. \r\nНо, зная имя ограничения, мы можем к нему обращаться, например, для его удаления. \r\n И также можно задать все имена ограничений через атрибуты таблицы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL,\r\n    Age INTEGER,\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(20),\r\n\tCONSTRAINT customer_Id PRIMARY KEY(Id),\r\n\tCONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),\r\n\tCONSTRAINT customers_email_key UNIQUE(Email),\r\n\tCONSTRAINT customers_phone_key UNIQUE(Phone)\r\n);\r\n \r\n Вне зависимости от того, используется оператор CONSTRAINT для создания ограничений или нет (в этом случае при установке ограничений PostgreSQL сам дает им имена), \r\nмы можем просмотреть все ограничения в pgAdmin в узле базы данных в подузле  : \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Ограничения столбцов и таблиц</h2><div class=\"date\">Последнее обновление: 23.10.2020</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>При определении таблиц и их столбцов в SQL мы можем использовать ряд атрибутов, которые накладывают определенные ограничения. \r\nРассмотрим эти атрибуты.</p>\r\n<h3>PRIMARY KEY</h3>\r\n<p>С помощью выражения <span class=\"b\">PRIMARY KEY</span> столбец можно сделать первичным ключом.</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n    Email CHARACTER VARYING(30),\r\n    Age INTEGER\r\n)\r\n</pre>\r\n<p>Первичный ключ уникально идентифицирует строку в таблице. В качестве первичного ключа необязательно должны выступать столбцы с типом <code>SERIAL</code>, они могут представлять \r\nлюбой другой тип.</p>\r\n<p>Установка первичного ключа на уровне таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL,\r\n    FirstName CHARACTER VARYING(30),\r\n    LastName CHARACTER VARYING(30),\r\n    Email CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n    PRIMARY KEY(Id)\r\n);\r\n</pre>\r\n<p>Первичный ключ может быть составным (compound key). Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать \r\nстроку в таблице. Например:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE OrderLines\r\n(\r\n\tOrderId INTEGER,\r\n\tProductId INTEGER,\r\n\tQuantity INTEGER,\r\n\tPrice MONEY,\r\n\tPRIMARY KEY(OrderId, ProductId)\r\n);\r\n</pre>\r\n<p>Здесь поля OrderId и ProductId вместе выступают как составной первичный ключ. То есть в таблице OrderLines не может быть двух строк, где для обоих из этих полей одновременно \r\nбыли бы одни и те же значения.</p>\r\n<h3>UNIQUE</h3>\r\n<p>Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут <span class=\"b\">UNIQUE</span>.</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30) UNIQUE,\r\n    Phone CHARACTER VARYING(30) UNIQUE,\r\n    Age INTEGER\r\n);\r\n</pre>\r\n<p>В данном случае столбцы, которые представляют электронный адрес и телефон, будут иметь уникальные значения. И мы не сможем добавить в таблицу две строки, у которых \r\nзначения для этих столбцов будет совпадать.</p>\r\n<p>Также мы можем определить этот атрибут на уровне таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n\tUNIQUE(Email, Phone)\r\n);\r\n</pre>\r\n<p>Или так:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(30),\r\n    Age INTEGER,\r\n\tUNIQUE(Email), \r\n\tUNIQUE(Phone)\r\n);\r\n</pre>\r\n<h3>NULL и NOT NULL</h3>\r\n<p>Чтобы указать, может ли столбец принимать значение NULL, при определении столбца ему можно задать атрибут <span class=\"b\">NULL</span> или \r\n<span class=\"b\">NOT NULL</span>. Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение NULL. \r\nИсключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае по умолчанию столбец имеет значение NOT NULL.</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Age INTEGER\r\n);\r\n</pre>\r\n<h3>DEFAULT</h3>\r\n<p>Атрибут <span class=\"b\">DEFAULT</span> определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет \r\nиспользоваться значение по умолчанию.</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Age INTEGER DEFAULT 18\r\n);\r\n</pre>\r\n<p>Здесь для столбца Age предусмотрено значение по умолчанию 18.</p>\r\n<h3>CHECK</h3>\r\n<p>Ключевое слово <span class=\"b\">CHECK</span> задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после слова CHECK \r\nуказывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName CHARACTER VARYING(20),\r\n    LastName CHARACTER VARYING(20),\r\n    Age INTEGER DEFAULT 18 CHECK(Age &gt;0 AND Age &lt; 100),\r\n\tEmail CHARACTER VARYING(30) UNIQUE CHECK(Email !=''),\r\n    Phone CHARACTER VARYING(20) UNIQUE CHECK(Phone !='')\r\n);\r\n</pre>\r\n<p>Здесь также указывается, что столбцы Email и Phone не могут иметь пустую строку в качестве значения (пустая строка <span class=\"b\">не</span> эквивалентна значению NULL).</p>\r\n<p>Для соединения условий используется ключевое слово <span class=\"b\">AND</span>. Условия можно задать в виде операций сравнения больше (&gt;), меньше (&lt;), не равно (!=).</p>\r\n<p>Также с помощью CHECK можно создать ограничение в целом для таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tAge INTEGER DEFAULT 18,\r\n\tFirstName CHARACTER VARYING(20),\r\n\tLastName CHARACTER VARYING(20),\r\n\tEmail CHARACTER VARYING(30) UNIQUE,\r\n\tPhone CHARACTER VARYING(20) UNIQUE,\r\n\tCHECK((Age &gt;0 AND Age&lt;100) AND (Email !='') AND (Phone !=''))\r\n);\r\n</pre>\r\n<h3>Оператор CONSTRAINT. Установка имени ограничений.</h3>\r\n<p>С помощью ключевого слова <span class=\"b\">CONSTRAINT</span> можно задать имя для ограничений. В качестве ограничений могут использоваться \r\nPRIMARY KEY, UNIQUE, CHECK.</p>\r\n<p>Имена ограничений можно задать на уровне столбцов. Они указываются после CONSTRAINT перед атрибутами:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,\r\n    Age INTEGER CONSTRAINT customers_age_check CHECK(Age &gt;0 AND Age &lt; 100),\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Email CHARACTER VARYING(30) CONSTRAINT customers_email_key UNIQUE,\r\n    Phone CHARACTER VARYING(20) CONSTRAINT customers_phone_key UNIQUE\r\n);\r\n</pre>\r\n\r\n<p>В принципе необязательно задавать имена ограничений, при установке соответствующих атрибутов SQL Server автоматически определяет их имена. \r\nНо, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.</p>\r\n<p>И также можно задать все имена ограничений через атрибуты таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL,\r\n    Age INTEGER,\r\n    FirstName CHARACTER VARYING(20) NOT NULL,\r\n    LastName CHARACTER VARYING(20) NOT NULL,\r\n    Email CHARACTER VARYING(30),\r\n    Phone CHARACTER VARYING(20),\r\n\tCONSTRAINT customer_Id PRIMARY KEY(Id),\r\n\tCONSTRAINT customers_age_check CHECK(Age &gt;0 AND Age &lt; 100),\r\n\tCONSTRAINT customers_email_key UNIQUE(Email),\r\n\tCONSTRAINT customers_phone_key UNIQUE(Phone)\r\n);\r\n</pre>\r\n<p>Вне зависимости от того, используется оператор CONSTRAINT для создания ограничений или нет (в этом случае при установке ограничений PostgreSQL сам дает им имена), \r\nмы можем просмотреть все ограничения в pgAdmin в узле базы данных в подузле <span class=\"b\"></span>:</p>\r\n<img src=\"pics/2.7.png\" alt=\"Ограничения в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.3.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.5.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.5.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 19.03.2018", "title": "Внешние ключи", "text": "\n Внешние ключи Последнее обновление: 19.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для связи между таблицами применяются внешние ключи. Внешний ключ устанавливается для столбца из зависимой, подчиненной таблицы \r\n(referencing table), и указывает на один из столбцов из главной таблицы (referenced table). Как правило, внешний ключ указывает на \r\nпервичный ключ из связанной главной таблицы. \r\n Общий синтаксис установки внешнего ключа на уровне столбца: \r\n \r\nREFERENCES главная_таблица (столбец_главной_таблицы)\r\n\t[ON DELETE {CASCADE|RESTRICT}]\r\n\t[ON UPDATE {CASCADE|RESTRICT}]\r\n \r\n Чтобы установить связь между таблицами, после ключевого слова  REFERENCES  указывается имя связанной таблицы и далее в \r\nскобках имя столбца из этой таблицы, на который будет указывать внешний ключ. После выражения REFERENCES может идти выражение  ON DELETE  и  ON UPDATE , которые уточняют поведение при удалении или обновлении данных. \r\n Общий синтаксис установки внешнего ключа на уровне таблицы: \r\n \r\nFOREIGN KEY (стобец1, столбец2, ... столбецN) \r\n\tREFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)\r\n\t[ON DELETE {CASCADE|RESTRICT}]\r\n\t[ON UPDATE {CASCADE|RESTRICT}]\r\n \r\n Например, определим две таблицы и свяжем их посредством внешнего ключа: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Age INTEGER, \r\n    FirstName VARCHAR(20) NOT NULL\r\n);\r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER REFERENCES Customers (Id),\r\n    Quantity INTEGER\r\n);\r\n \r\n Здесь определены таблицы Customers и Orders. Customers является главной и представляет клиента. \r\nOrders является зависимой и представляет заказ, сделанный клиентом. Эта таблица через столбец CustomerId связана с таблицей Customers и ее столбцом Id. \r\nТо есть столбец CustomerId является внешним ключом, который указывает на столбец Id из таблицы Customers. \r\n Определение внешнего ключа на уровне таблицы выглядело бы следующим образом: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Age INTEGER, \r\n    FirstName VARCHAR(20) NOT NULL\r\n);\r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id)\r\n);\r\n \r\n ON DELETE и ON UPDATE \r\n С помощью выражений  ON DELETE  и  ON UPDATE  можно установить действия, которые выполняются \r\nсоответственно при удалении и изменении связанной строки из главной таблицы. Для установки подобного действия можно использовать следующие опции: \r\n \r\n CASCADE : автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице. \r\n RESTRICT : предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. \r\nТо есть фактически какие-либо действия отсутствуют. \r\n NO ACTION : действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. \r\nИ генерирует ошибку. В отличие от  RESTRICT  выполняет отложенную проверку на связанность между таблицами. \r\n SET NULL : при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. \r\n SET DEFAULT : при удалении связанной строки из главной таблицы устанавливает для \r\nстолбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL. \r\n \r\n Каскадное удаление \r\n По умолчанию, если на строку из главной таблицы по внешнему ключу ссылается какая-либо строка из зависимой таблицы, \r\nто мы не сможем удалить эту строку из главной таблицы. Вначале нам необходимо будет удалить все связанные строки из зависимой таблицы. И \r\nесли при удалении строки из главной таблицы необходимо, чтобы были удалены все связанные строки из зависимой таблицы, то применяется каскадное удаление, то есть \r\nопция  CASCADE : \r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE\r\n);\r\n \r\n Аналогично работает выражение  ON UPDATE CASCADE . При изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. \r\nНо так как первичные ключи, как правило, изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, \r\nто на практике выражение  ON UPDATE  используется редко. \r\n Установка NULL \r\n При установки для внешнего ключа опции  SET NULL  необходимо, чтобы столбец внешнего ключа допускал значение NULL: \r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL\r\n);\r\n \r\n Установка значения по умолчанию \r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER DEFAULT 1,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT\r\n);\r\n \r\n Если для столца значение по умолчанию не задано через параметр DEFAULT, то в качестве такового используется значение NULL (если столбец допускает NULL). \r\n\n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Внешние ключи</h2><div class=\"date\">Последнее обновление: 19.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для связи между таблицами применяются внешние ключи. Внешний ключ устанавливается для столбца из зависимой, подчиненной таблицы \r\n(referencing table), и указывает на один из столбцов из главной таблицы (referenced table). Как правило, внешний ключ указывает на \r\nпервичный ключ из связанной главной таблицы.</p>\r\n<p>Общий синтаксис установки внешнего ключа на уровне столбца:</p>\r\n<pre class=\"brush:sql;\">\r\nREFERENCES главная_таблица (столбец_главной_таблицы)\r\n\t[ON DELETE {CASCADE|RESTRICT}]\r\n\t[ON UPDATE {CASCADE|RESTRICT}]\r\n</pre>\r\n<p>Чтобы установить связь между таблицами, после ключевого слова <span class=\"b\">REFERENCES</span> указывается имя связанной таблицы и далее в \r\nскобках имя столбца из этой таблицы, на который будет указывать внешний ключ. После выражения REFERENCES может идти выражение <span class=\"b\">ON DELETE</span> и <span class=\"b\">ON UPDATE</span>, которые уточняют поведение при удалении или обновлении данных.</p>\r\n<p>Общий синтаксис установки внешнего ключа на уровне таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nFOREIGN KEY (стобец1, столбец2, ... столбецN) \r\n\tREFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)\r\n\t[ON DELETE {CASCADE|RESTRICT}]\r\n\t[ON UPDATE {CASCADE|RESTRICT}]\r\n</pre>\r\n<p>Например, определим две таблицы и свяжем их посредством внешнего ключа:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Age INTEGER, \r\n    FirstName VARCHAR(20) NOT NULL\r\n);\r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER REFERENCES Customers (Id),\r\n    Quantity INTEGER\r\n);\r\n</pre>\r\n<p>Здесь определены таблицы Customers и Orders. Customers является главной и представляет клиента. \r\nOrders является зависимой и представляет заказ, сделанный клиентом. Эта таблица через столбец CustomerId связана с таблицей Customers и ее столбцом Id. \r\nТо есть столбец CustomerId является внешним ключом, который указывает на столбец Id из таблицы Customers.</p>\r\n<p>Определение внешнего ключа на уровне таблицы выглядело бы следующим образом:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    Age INTEGER, \r\n    FirstName VARCHAR(20) NOT NULL\r\n);\r\n \r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id)\r\n);\r\n</pre>\r\n<h3>ON DELETE и ON UPDATE</h3>\r\n<p>С помощью выражений <span class=\"b\">ON DELETE</span> и <span class=\"b\">ON UPDATE</span> можно установить действия, которые выполняются \r\nсоответственно при удалении и изменении связанной строки из главной таблицы. Для установки подобного действия можно использовать следующие опции:</p>\r\n<ul>\r\n<li><p><span class=\"b\">CASCADE</span>: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.</p></li>\r\n<li><p><span class=\"b\">RESTRICT</span>: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. \r\nТо есть фактически какие-либо действия отсутствуют.</p></li>\r\n<li><p><span class=\"b\">NO ACTION</span>: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. \r\nИ генерирует ошибку. В отличие от <code>RESTRICT</code> выполняет отложенную проверку на связанность между таблицами.</p></li>\r\n<li><p><span class=\"b\">SET NULL</span>: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.</p></li>\r\n<li><p><span class=\"b\">SET DEFAULT</span>: при удалении связанной строки из главной таблицы устанавливает для \r\nстолбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL.</p></li>\r\n</ul>\r\n<h3>Каскадное удаление</h3>\r\n<p>По умолчанию, если на строку из главной таблицы по внешнему ключу ссылается какая-либо строка из зависимой таблицы, \r\nто мы не сможем удалить эту строку из главной таблицы. Вначале нам необходимо будет удалить все связанные строки из зависимой таблицы. И \r\nесли при удалении строки из главной таблицы необходимо, чтобы были удалены все связанные строки из зависимой таблицы, то применяется каскадное удаление, то есть \r\nопция <span class=\"b\">CASCADE</span>:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE\r\n);\r\n</pre>\r\n<p>Аналогично работает выражение <span class=\"b\">ON UPDATE CASCADE</span>. При изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. \r\nНо так как первичные ключи, как правило, изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, \r\nто на практике выражение <span class=\"b\">ON UPDATE</span> используется редко.</p>\r\n<h3>Установка NULL</h3>\r\n<p>При установки для внешнего ключа опции <span class=\"b\">SET NULL</span> необходимо, чтобы столбец внешнего ключа допускал значение NULL:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL\r\n);\r\n</pre>\r\n<h3>Установка значения по умолчанию</h3>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    CustomerId INTEGER DEFAULT 1,\r\n    Quantity INTEGER,\r\n\tFOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT\r\n);\r\n</pre>\r\n<p>Если для столца значение по умолчанию не задано через параметр DEFAULT, то в качестве такового используется значение NULL (если столбец допускает NULL).</p>\r\n\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.4.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"2.6.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/2.6.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 19.03.2018", "title": "Изменение таблиц", "text": "\n Изменение таблиц Последнее обновление: 19.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Нередко возникает изменить уже имеющуюся таблицу, в частности, добавить или удалить столбцы, изменить тип столбцов и т.д.. \r\nТо есть потребуется изменить определение таблицы. Для этого применяется выражение  ALTER TABLE , \r\nкоторое имеет следующий формальный синтаксис: \r\n \r\nALTER TABLE название_таблицы\r\n{ ADD название_столбца тип_данных_столбца [ограничения_столбца] | \r\n  DROP COLUMN название_столбца |\r\n  ALTER COLUMN название_столбца параметры_столбца |\r\n  ADD [CONSTRAINT] определение_ограничения |\r\n  DROP [CONSTRAINT] имя_ограничения}\r\n \r\n Рассмотрим некоторые возможности по изменению таблицы. \r\n Добавление нового столбца \r\n Добавим в таблицу Customers новый столбец Phone: \r\n \r\nALTER TABLE Customers\r\nADD Phone CHARACTER VARYING(20) NULL;\r\n \r\n Здесь столбец Phone имеет тип  CHARACTER VARYING(20) , и для него определен атрибут  NULL , то есть \r\nстолбец допускает отсутствие значения. Но что если нам надо добавить столбец, который не должен принимать значения NULL? Если в таблице есть \r\nданные, то следующая команда не будет выполнена: \r\n \r\nALTER TABLE Customers\r\nADD Address CHARACTER VARYING(30) NOT NULL;\r\n \r\n Поэтому в данном случае решение состоит в установке значения по умолчанию через атрибут  DEFAULT : \r\n \r\nALTER TABLE Customers\r\nADD Address CHARACTER VARYING(30) NOT NULL DEFAULT 'Неизвестно';\r\n \r\n Удаление столбца \r\n Удалим столбец Address из таблицы Customers: \r\n \r\nALTER TABLE Customers\r\nDROP COLUMN Address;\r\n \r\n Изменение типа столбца \r\n Для изменения типа применяется ключевое слово  TYPE . Изменим в таблице Customers тип данных у столбца FirstName на  VARCHAR(50)  (он же  VARYING CHARACTER(50) ): \r\n \r\nALTER TABLE Customers\r\nALTER COLUMN FirstName TYPE VARCHAR(50);\r\n \r\n Изменение ограничений столбца \r\n Для добавления ограничения применяется оператор  SET , после которого указывается ограничение. \r\nНапример, установим для столбца FirstName ограничение  NOT NULL : \r\n \r\nALTER TABLE Customers \r\nALTER COLUMN FirstName \r\nSET NOT NULL;\r\n \r\n Для удаления ограничения применяется оператор  DROP , после которого указывается ограничение. \r\nНапример, удалим выше установленное ограничение: \r\n \r\nALTER TABLE Customers \r\nALTER COLUMN FirstName \r\nDROP NOT NULL;\r\n \r\n Изменение ограничений таблицы \r\n Добавление ограничения  CHECK : \r\n \r\nALTER TABLE Customers\r\nADD CHECK (Age > 0);\r\n \r\n Добавление первичного ключа  PRIMARY KEY : \r\n \r\nALTER TABLE Customers \r\nADD PRIMARY KEY (Id);\r\n \r\n В данном случае предполагается, что в таблице уже есть столбец Id, который не имеет ограничения PRIMARY KEY. А с помощью вышеуказанного скрипта устанавливается ограничение PRIMARY KEY. \r\n Добавление ограничение  UNIQUE  - определим для столбца Email уникальные значения: \r\n \r\nALTER TABLE Customers\r\nADD UNIQUE (Email);\r\n \r\n При добавлении ограничения каждому из них дается определенное имя. Например, выше добавленное ограничение для CHECK будет называться \r\n customers_age_check . Имена ограничений можно посмотреть в таблице через pgAdmin. \r\n Также мы можем явным образом назначить ограничению при добавлении имя с помощью оператора  CONSTRAINT . \r\n \r\nALTER TABLE Customers\r\nADD CONSTRAINT phone_unique UNIQUE (Phone);\r\n \r\n В данном случае ограничение будет называться \"phone_unique\". \r\n Чтобы удалить ограничение, надо знать его имя, которое указывается после выражения  DROP CONSTRAINT . Например, удалим выше добавленное ограничение: \r\n \r\nALTER TABLE Customers\r\nDROP CONSTRAINT phone_unique;\r\n \r\n Переименование столбца и таблицы \r\n Переименуем столбец Address в City: \r\n \r\nALTER TABLE Customers\r\nRENAME COLUMN Address TO City;\r\n \r\n Переименуем таблицу Customers в Users: \r\n \r\nALTER TABLE Customers\r\nRENAME TO Users;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Изменение таблиц</h2><div class=\"date\">Последнее обновление: 19.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Нередко возникает изменить уже имеющуюся таблицу, в частности, добавить или удалить столбцы, изменить тип столбцов и т.д.. \r\nТо есть потребуется изменить определение таблицы. Для этого применяется выражение <span class=\"b\">ALTER TABLE</span>, \r\nкоторое имеет следующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE название_таблицы\r\n{ ADD название_столбца тип_данных_столбца [ограничения_столбца] | \r\n  DROP COLUMN название_столбца |\r\n  ALTER COLUMN название_столбца параметры_столбца |\r\n  ADD [CONSTRAINT] определение_ограничения |\r\n  DROP [CONSTRAINT] имя_ограничения}\r\n</pre>\r\n<p>Рассмотрим некоторые возможности по изменению таблицы.</p>\r\n<h3>Добавление нового столбца</h3>\r\n<p>Добавим в таблицу Customers новый столбец Phone:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD Phone CHARACTER VARYING(20) NULL;\r\n</pre>\r\n<p>Здесь столбец Phone имеет тип <code>CHARACTER VARYING(20)</code>, и для него определен атрибут <code>NULL</code>, то есть \r\nстолбец допускает отсутствие значения. Но что если нам надо добавить столбец, который не должен принимать значения NULL? Если в таблице есть \r\nданные, то следующая команда не будет выполнена:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD Address CHARACTER VARYING(30) NOT NULL;\r\n</pre>\r\n<p>Поэтому в данном случае решение состоит в установке значения по умолчанию через атрибут <code>DEFAULT</code>:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD Address CHARACTER VARYING(30) NOT NULL DEFAULT 'Неизвестно';\r\n</pre>\r\n<h3>Удаление столбца</h3>\r\n<p>Удалим столбец Address из таблицы Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nDROP COLUMN Address;\r\n</pre>\r\n<h3>Изменение типа столбца</h3>\r\n<p>Для изменения типа применяется ключевое слово <span class=\"b\">TYPE</span>. Изменим в таблице Customers тип данных у столбца FirstName на <code>VARCHAR(50)</code> (он же <code>VARYING CHARACTER(50)</code>):</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nALTER COLUMN FirstName TYPE VARCHAR(50);\r\n</pre>\r\n<h3>Изменение ограничений столбца</h3>\r\n<p>Для добавления ограничения применяется оператор <span class=\"b\">SET</span>, после которого указывается ограничение. \r\nНапример, установим для столбца FirstName ограничение <code>NOT NULL</code>:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers \r\nALTER COLUMN FirstName \r\nSET NOT NULL;\r\n</pre>\r\n<p>Для удаления ограничения применяется оператор <span class=\"b\">DROP</span>, после которого указывается ограничение. \r\nНапример, удалим выше установленное ограничение:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers \r\nALTER COLUMN FirstName \r\nDROP NOT NULL;\r\n</pre>\r\n<h3>Изменение ограничений таблицы</h3>\r\n<p>Добавление ограничения <span class=\"b\">CHECK</span>:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD CHECK (Age &gt; 0);\r\n</pre>\r\n<p>Добавление первичного ключа <code>PRIMARY KEY</code>:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers \r\nADD PRIMARY KEY (Id);\r\n</pre>\r\n<p>В данном случае предполагается, что в таблице уже есть столбец Id, который не имеет ограничения PRIMARY KEY. А с помощью вышеуказанного скрипта устанавливается ограничение PRIMARY KEY.</p>\r\n<p>Добавление ограничение <code>UNIQUE</code> - определим для столбца Email уникальные значения:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD UNIQUE (Email);\r\n</pre>\r\n<p>При добавлении ограничения каждому из них дается определенное имя. Например, выше добавленное ограничение для CHECK будет называться \r\n<code>customers_age_check</code>. Имена ограничений можно посмотреть в таблице через pgAdmin.</p><p>\r\n</p><p>Также мы можем явным образом назначить ограничению при добавлении имя с помощью оператора <span class=\"b\">CONSTRAINT</span>.</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nADD CONSTRAINT phone_unique UNIQUE (Phone);\r\n</pre>\r\n<p>В данном случае ограничение будет называться \"phone_unique\".</p>\r\n<p>Чтобы удалить ограничение, надо знать его имя, которое указывается после выражения <code>DROP CONSTRAINT</code>. Например, удалим выше добавленное ограничение:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nDROP CONSTRAINT phone_unique;\r\n</pre>\r\n<h3>Переименование столбца и таблицы</h3>\r\n<p>Переименуем столбец Address в City:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nRENAME COLUMN Address TO City;\r\n</pre>\r\n<p>Переименуем таблицу Customers в Users:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TABLE Customers\r\nRENAME TO Users;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.5.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"3.1.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/3.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 20.03.2018", "title": "Добавление данных. Команда Insert", "text": "\n Операции с данными Добавление данных. Команда Insert Последнее обновление: 20.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для добавления данных применяется команда  INSERT , которая имеет следующий формальный синтаксис: \r\n \r\nINSERT INTO имя_таблицы (столбец1, столбец2, ... столбецN) \r\nVALUES (значение1, значение2, ... значениеN)\r\n \r\n После  INSERT INTO  идет имя таблицы, затем в скобках указываются все столбцы через запятую, в которые надо добавлять \r\nданные. И в конце после слова  VALUES  в скобках перечисляются добавляемые значения.  \r\n Допустим, у нас в базе данных есть следующая талица: \r\n \r\nCREATE TABLE Products\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tProductName VARCHAR(30) NOT NULL,\r\n\tManufacturer VARCHAR(20) NOT NULL,\r\n\tProductCount INTEGER DEFAULT 0,\r\n\tPrice NUMERIC\r\n);\r\n \r\n Добавим в нее одну строку с помощью команды INSERT: \r\n \r\nINSERT INTO Products VALUES (1, 'Galaxy S9', 'Samsung', 4, 63000)\r\n \r\n После удачного выполнения в pgAdmin в поле сообщений должно появиться сообщение \"INSERT 0 1\": \r\n \r\n Стоит учитывать, что значения для столбцов в скобках после ключевого слова VALUES передаются по порядку их объявления. Например, в выражении \r\nCREATE TABLE выше можно увидеть, что первым столбцом идет Id, поэтому этому столбцу передаетсячисло 1. \r\nВторой столбец называется ProductName, поэтому второе значение - строка \"Galaxy S9\" будет передано именно этому столбцу и так далее. \r\nТо есть значения передаются столбцам следующим образом: \r\n \r\n Id: 1 \r\n ProductName: 'Galaxy S9' \r\n Manufacturer: 'Samsung' \r\n ProductCount: 4 \r\n Price: 63000 \r\n \r\n Также при вводе значений можно указать непосредственные столбцы, в которые будут добавляться значения: \r\n \r\nINSERT INTO Products (ProductName, Price, Manufacturer) \r\nVALUES ('iPhone X', 71000, 'Apple');\r\n \r\n Здесь значение указывается только для трех столбцов. Причем теперь значения передаются в порядке следования столбцов: \r\n \r\n ProductName: 'iPhone X' \r\n Manufacturer: 'Apple' \r\n Price: 71000 \r\n \r\n Для столбца Id значение будет генерироваться автоматически базой данных, так как он представляет тип Serial. То есть к значению из последней строки \r\nбудет добавляться единица. \r\n Для остальных столбцов будет добавляться значение по умолчанию, если задан атрибут DEFAULT (например, для столбца ProductCount), \r\nзначение NULL. При этом неуказанные столбцы (за исключением тех, которые имеют тип Serial) должны допускать значение NULL или иметь атрибут DEFAULT. \r\n Если конкретные столбцы не указываются, как в первом примере, тогда мы должны передать значения для всех столбцов в таблице. \r\n Также мы можем добавить сразу несколько строк: \r\n \r\nINSERT INTO Products  (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES \r\n('iPhone 6', 'Apple', 3, 36000),\r\n('Galaxy S8', 'Samsung', 2, 46000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000)\r\n \r\n В данном случае в таблицу будут добавлены три строки. \r\n Возвращение значений \r\n Если мы добавляем значения только для части столбцов, то мы можем не знать, какие значения будут у других столбцов. Например, какое значени \r\nполучит столбец Id у товара. С помощью оператора  RETURNING  мы можем получить это значение: \r\n \r\nINSERT INTO Products \r\n(ProductName, Manufacturer, ProductCount, Price) \r\nVALUES('Desire 12', 'HTC', 8, 21000) RETURNING id;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Операции с данными</h1><h2>Добавление данных. Команда Insert</h2><div class=\"date\">Последнее обновление: 20.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для добавления данных применяется команда <span class=\"b\">INSERT</span>, которая имеет следующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO имя_таблицы (столбец1, столбец2, ... столбецN) \r\nVALUES (значение1, значение2, ... значениеN)\r\n</pre>\r\n<p>После <span class=\"b\">INSERT INTO</span> идет имя таблицы, затем в скобках указываются все столбцы через запятую, в которые надо добавлять \r\nданные. И в конце после слова <span class=\"b\">VALUES</span> в скобках перечисляются добавляемые значения. </p>\r\n<p>Допустим, у нас в базе данных есть следующая талица:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tProductName VARCHAR(30) NOT NULL,\r\n\tManufacturer VARCHAR(20) NOT NULL,\r\n\tProductCount INTEGER DEFAULT 0,\r\n\tPrice NUMERIC\r\n);\r\n</pre>\r\n<p>Добавим в нее одну строку с помощью команды INSERT:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products VALUES (1, 'Galaxy S9', 'Samsung', 4, 63000)\r\n</pre>\r\n<p>После удачного выполнения в pgAdmin в поле сообщений должно появиться сообщение \"INSERT 0 1\":</p>\r\n<img src=\"pics/3.1.png\" alt=\"INSERT INTO в PostgreSQL\">\r\n<p>Стоит учитывать, что значения для столбцов в скобках после ключевого слова VALUES передаются по порядку их объявления. Например, в выражении \r\nCREATE TABLE выше можно увидеть, что первым столбцом идет Id, поэтому этому столбцу передаетсячисло 1. \r\nВторой столбец называется ProductName, поэтому второе значение - строка \"Galaxy S9\" будет передано именно этому столбцу и так далее. \r\nТо есть значения передаются столбцам следующим образом:</p>\r\n<ul>\r\n<li><p>Id: 1</p></li>\r\n<li><p>ProductName: 'Galaxy S9'</p></li>\r\n<li><p>Manufacturer: 'Samsung'</p></li>\r\n<li><p>ProductCount: 4</p></li>\r\n<li><p>Price: 63000</p></li>\r\n</ul>\r\n<p>Также при вводе значений можно указать непосредственные столбцы, в которые будут добавляться значения:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products (ProductName, Price, Manufacturer) \r\nVALUES ('iPhone X', 71000, 'Apple');\r\n</pre>\r\n<p>Здесь значение указывается только для трех столбцов. Причем теперь значения передаются в порядке следования столбцов:</p>\r\n<ul>\r\n<li><p>ProductName: 'iPhone X'</p></li>\r\n<li><p>Manufacturer: 'Apple'</p></li>\r\n<li><p>Price: 71000</p></li>\r\n</ul>\r\n<p>Для столбца Id значение будет генерироваться автоматически базой данных, так как он представляет тип Serial. То есть к значению из последней строки \r\nбудет добавляться единица.</p>\r\n<p>Для остальных столбцов будет добавляться значение по умолчанию, если задан атрибут DEFAULT (например, для столбца ProductCount), \r\nзначение NULL. При этом неуказанные столбцы (за исключением тех, которые имеют тип Serial) должны допускать значение NULL или иметь атрибут DEFAULT.</p>\r\n<p>Если конкретные столбцы не указываются, как в первом примере, тогда мы должны передать значения для всех столбцов в таблице.</p>\r\n<p>Также мы можем добавить сразу несколько строк:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products  (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES \r\n('iPhone 6', 'Apple', 3, 36000),\r\n('Galaxy S8', 'Samsung', 2, 46000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000)\r\n</pre>\r\n<p>В данном случае в таблицу будут добавлены три строки.</p>\r\n<h3>Возвращение значений</h3>\r\n<p>Если мы добавляем значения только для части столбцов, то мы можем не знать, какие значения будут у других столбцов. Например, какое значени \r\nполучит столбец Id у товара. С помощью оператора <span class=\"b\">RETURNING</span> мы можем получить это значение:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products \r\n(ProductName, Manufacturer, ProductCount, Price) \r\nVALUES('Desire 12', 'HTC', 8, 21000) RETURNING id;\r\n</pre>\r\n<img src=\"pics/3.2.png\" alt=\"RETURNING in PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"2.6.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"3.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/3.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 20.03.2018", "title": "Получение данных. Команда Select", "text": "\n Получение данных. Команда Select Последнее обновление: 20.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для извлечения данных из БД применяется команда  SELECT . В упрощенном виде она имеет следующий синтаксис: \r\n SELECT список_столбцов FROM имя_таблицы \r\n Например, пусть ранее была создана таблица Products, и в нее добавлены некоторые начальные данные: \r\n \r\nCREATE TABLE Products\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tProductName VARCHAR(30) NOT NULL,\r\n\tManufacturer VARCHAR(20) NOT NULL,\r\n\tProductCount INTEGER DEFAULT 0,\r\n\tPrice NUMERIC\r\n);\r\n\r\nINSERT INTO Products (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES\r\n('iPhone X', 'Apple', 3, 36000),\r\n('iPhone 8', 'Apple', 2, 41000),\r\n('Galaxy S9', 'Samsung', 2, 46000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000),\r\n('Desire 12', 'HTC', 5, 28000);\r\n \r\n Получим все объекты из этой таблицы: \r\n \r\nSELECT * FROM Products;\r\n \r\n Символ звездочка * указывает, что нам надо получить все столбцы. \r\n \r\n Однако использование символа звездочки * считается не очень хорошей практикой, так как, как правило, не все столбцы бывают нужны. И более \r\nоптимальный подход заключается в указании всех необходимых столбцов после слова SELECT. Исключение составляет тот случай, когда надо получить данные по абсолютно всем столбцам таблицы. \r\nТакже использование символа * может быть предпочтительно в таких ситуациях, когда в точности не известны названия столбцов. \r\n Если нам надо получить данные не по всем, а по каким-то конкретным столбцам, то тогда все эти спецификации столбцов перечисляются через запятую после SELECT: \r\n \r\nSELECT ProductName, Price FROM Products;\r\n \r\n \r\n Спецификация столбца необязательно должна представлять его название. Это может быть любое выражение, например, результат арифметической операции. \r\nТак, выполним следующий запрос: \r\n \r\nSELECT ProductCount, Manufacturer, Price * ProductCount\r\nFROM Products;\r\n \r\n Здесь при выборке будут создаваться три столбца. Причем третий столбец представляет значение столбца Price, умноженное на значение столбца \r\nProductCount, то есть совокупную стоимость товара. \r\n С помощью оператора  AS  можно изменить название выходного столбца или определить его псевдоним: \r\n \r\nSELECT ProductCount AS Title, \r\nManufacturer, \r\nPrice * ProductCount  AS TotalSum\r\nFROM Products;\r\n \r\n В данном случае результатом выборки являются данные по 3-м столбцам. Для первого столбца определяется псевдоним Title, хотя в реальности \r\nон будет представлять столбец ProductName. Второй столбец сохраняет свое название - Manufacturer. Третий столбец TotalSum хранит произведение столбцов \r\nProductCount и Price. \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Получение данных. Команда Select</h2><div class=\"date\">Последнее обновление: 20.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для извлечения данных из БД применяется команда <span class=\"b\">SELECT</span>. В упрощенном виде она имеет следующий синтаксис:</p>\r\n<pre class=\"brush:sql;\">SELECT список_столбцов FROM имя_таблицы</pre>\r\n<p>Например, пусть ранее была создана таблица Products, и в нее добавлены некоторые начальные данные:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n\tId SERIAL PRIMARY KEY,\r\n\tProductName VARCHAR(30) NOT NULL,\r\n\tManufacturer VARCHAR(20) NOT NULL,\r\n\tProductCount INTEGER DEFAULT 0,\r\n\tPrice NUMERIC\r\n);\r\n\r\nINSERT INTO Products (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES\r\n('iPhone X', 'Apple', 3, 36000),\r\n('iPhone 8', 'Apple', 2, 41000),\r\n('Galaxy S9', 'Samsung', 2, 46000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000),\r\n('Desire 12', 'HTC', 5, 28000);\r\n</pre>\r\n<p>Получим все объекты из этой таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products;\r\n</pre>\r\n<p>Символ звездочка * указывает, что нам надо получить все столбцы.</p>\r\n<img src=\"pics/3.3.png\" alt=\"SELECT и выборка из базы данных PostgreSQL\">\r\n<p>Однако использование символа звездочки * считается не очень хорошей практикой, так как, как правило, не все столбцы бывают нужны. И более \r\nоптимальный подход заключается в указании всех необходимых столбцов после слова SELECT. Исключение составляет тот случай, когда надо получить данные по абсолютно всем столбцам таблицы. \r\nТакже использование символа * может быть предпочтительно в таких ситуациях, когда в точности не известны названия столбцов.</p>\r\n<p>Если нам надо получить данные не по всем, а по каким-то конкретным столбцам, то тогда все эти спецификации столбцов перечисляются через запятую после SELECT:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Price FROM Products;\r\n</pre>\r\n<img src=\"pics/3.4.png\" alt=\"SELECT и выборка по столбцам из базы данных PostgreSQL\">\r\n<p>Спецификация столбца необязательно должна представлять его название. Это может быть любое выражение, например, результат арифметической операции. \r\nТак, выполним следующий запрос:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductCount, Manufacturer, Price * ProductCount\r\nFROM Products;\r\n</pre>\r\n<p>Здесь при выборке будут создаваться три столбца. Причем третий столбец представляет значение столбца Price, умноженное на значение столбца \r\nProductCount, то есть совокупную стоимость товара.</p>\r\n<p>С помощью оператора <span class=\"b\">AS</span> можно изменить название выходного столбца или определить его псевдоним:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductCount AS Title, \r\nManufacturer, \r\nPrice * ProductCount  AS TotalSum\r\nFROM Products;\r\n</pre>\r\n<p>В данном случае результатом выборки являются данные по 3-м столбцам. Для первого столбца определяется псевдоним Title, хотя в реальности \r\nон будет представлять столбец ProductName. Второй столбец сохраняет свое название - Manufacturer. Третий столбец TotalSum хранит произведение столбцов \r\nProductCount и Price.</p>\r\n<img src=\"pics/3.5.png\" alt=\"Оператор AS в PostgreSQL и псевдонимы столбцов\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"3.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"3.3.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/3.3.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 20.03.2018", "title": "Фильтрация. WHERE", "text": "\n Фильтрация. WHERE Последнее обновление: 20.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для фильтрации данных применяется оператор  WHERE , после которого \r\nуказывается условие, на основании которого производится фильтрация: \r\n WHERE условие \r\n Если условие истинно, то строка попадает в результирующую выборку. В качестве можно использовать операции сравнения. \r\nЭти операции сравнивают два выражения. В PostgreSQL можно применять следующие операции сравнения: \r\n \r\n = : сравнение на равенство \r\n <> : сравнение на неравенство \r\n < : меньше чем \r\n > : больше чем \r\n !< : не меньше чем \r\n !> : не больше чем \r\n <= : меньше чем или равно \r\n >= : больше чем или равно \r\n \r\n Например, найдем всех товары, производителем которых является компания Apple: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Apple';\r\n \r\n \r\n Стоит отметить, что в данном случае большое значение имеет регистр символов, к примеру, строка \"Apple\" не эквивалентна строке \"APPLE\" или \"apple\". \r\n Другой пример - найдем все товары, у которых цена меньше 29000: \r\n \r\nSELECT * FROM Products\r\nWHERE Price < 39000;\r\n \r\n В качестве условия могут использоваться и более сложные выражения. Например, найдем все товары, у которых совокупная стоимость больше 90 000: \r\n \r\nSELECT * FROM Products\r\nWHERE Price * ProductCount > 90000;\r\n \r\n \r\n Логические операторы \r\n Чтобы объединить нескольких условий в одно, в PostgreSQL можно использовать логические операторы: \r\n \r\n AND : операция логического И. Она объединяет два выражения: \r\n выражение1 AND выражение2 \r\n Только если оба этих выражения одновременно истинны, то и общее условие оператора AND также будет истинно. То есть если и первое условие истинно, и второе. \r\n OR : операция логического ИЛИ. Она также объединяет два выражения: \r\n выражение1 OR выражение2 \r\n Если хотя бы одно из этих выражений истинно, то общее условие оператора OR также будет истинно. То есть если или первое условие истинно, или второе. \r\n NOT : операция логического отрицания. Если выражение в этой операции ложно, то общее условие истинно. \r\n NOT выражение \r\n \r\n \r\n Например, выберем все товары, у которых производитель Samsung и одновременно цена больше 50000: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' AND Price > 50000;\r\n \r\n \r\n Теперь изменим оператор на OR. То есть выберем все товары, у которых либо производитель Samsung, либо цена больше 50000: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Price > 50000;\r\n \r\n \r\n Применение оператора NOT - выберем все товары, у которых производитель не Samsung: \r\n \r\nSELECT * FROM Products\r\nWHERE NOT Manufacturer = 'Samsung';\r\n \r\n \r\n Но в большинстве случае вполне можно обойтись без оператора NOT. Так, в предыдущий пример мы можем переписать следующим образом: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer <> 'Samsung'\r\n \r\n Также в одной команде SELECT можно использовать сразу несколько операторов: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Price > 30000 AND ProductCount > 2;\r\n \r\n Так как оператор AND имеет более высокий приоритет, то сначала будет выполняться подвыражение \r\n Price > 30000 AND ProductCount > 2 , и только потом оператор OR. \r\nТо есть здесь выбираются товары, которыех на складе больше 2 и у которых одновременно цена больше 30000, либо те товары, \r\nпроизводителем которых является Samsung. \r\n С помощью скобок мы также можем переопределить порядок операций: \r\n \r\nSELECT * FROM Products\r\nWHERE (Manufacturer = 'Samsung' OR Price > 30000) AND ProductCount > 2;\r\n \r\n IS NULL \r\n Ряд столбцов может допускать значение NULL. Это значение не эквивалентно пустой строке ''. NULL представляет полное отсутствие какого-либо значения. \r\nИ для проверки на наличие подобного значения применяется оператор  IS NULL . \r\n Например, выберем все товары, у которых не установлено поле ProductCount: \r\n \r\nSELECT * FROM Products\r\nWHERE ProductCount IS NULL;\r\n \r\n Если, наоборот, необходимо получить строки, у которых поле ProductCount не равно NULL, то можно использовать оператор NOT: \r\n \r\nSELECT * FROM Products\r\nWHERE ProductCount IS NOT NULL;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Фильтрация. WHERE</h2><div class=\"date\">Последнее обновление: 20.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для фильтрации данных применяется оператор <span class=\"b\">WHERE</span>, после которого \r\nуказывается условие, на основании которого производится фильтрация:</p>\r\n<pre class=\"brush:sql;\">WHERE условие</pre>\r\n<p>Если условие истинно, то строка попадает в результирующую выборку. В качестве можно использовать операции сравнения. \r\nЭти операции сравнивают два выражения. В PostgreSQL можно применять следующие операции сравнения:</p>\r\n<ul>\r\n<li><p><span class=\"b\">=</span>: сравнение на равенство</p></li>\r\n<li><p><span class=\"b\">&lt;&gt;</span>: сравнение на неравенство</p></li>\r\n<li><p><span class=\"b\">&lt;</span>: меньше чем</p></li>\r\n<li><p><span class=\"b\">&gt;</span>: больше чем</p></li>\r\n<li><p><span class=\"b\">!&lt;</span>: не меньше чем</p></li>\r\n<li><p><span class=\"b\">!&gt;</span>: не больше чем</p></li>\r\n<li><p><span class=\"b\">&lt;=</span>: меньше чем или равно</p></li>\r\n<li><p><span class=\"b\">&gt;=</span>: больше чем или равно</p></li>\r\n</ul>\r\n<p>Например, найдем всех товары, производителем которых является компания Apple:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Apple';\r\n</pre>\r\n<img src=\"pics/3.6.png\" alt=\"Фильтрация WHERE в PostgreSQL\">\r\n<p>Стоит отметить, что в данном случае большое значение имеет регистр символов, к примеру, строка \"Apple\" не эквивалентна строке \"APPLE\" или \"apple\".</p>\r\n<p>Другой пример - найдем все товары, у которых цена меньше 29000:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Price &lt; 39000;\r\n</pre>\r\n<p>В качестве условия могут использоваться и более сложные выражения. Например, найдем все товары, у которых совокупная стоимость больше 90 000:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Price * ProductCount &gt; 90000;\r\n</pre>\r\n<img src=\"pics/3.7.png\" alt=\"Оператор WHERE в PostgreSQL\">\r\n<h3>Логические операторы</h3>\r\n<p>Чтобы объединить нескольких условий в одно, в PostgreSQL можно использовать логические операторы:</p>\r\n<ul>\r\n<li><p><span class=\"b\">AND</span>: операция логического И. Она объединяет два выражения:</p>\r\n<pre class=\"brush:sql;\">выражение1 AND выражение2</pre>\r\n<p>Только если оба этих выражения одновременно истинны, то и общее условие оператора AND также будет истинно. То есть если и первое условие истинно, и второе.</p></li>\r\n<li><p><span class=\"b\">OR</span>: операция логического ИЛИ. Она также объединяет два выражения:</p>\r\n<pre class=\"brush:sql;\">выражение1 OR выражение2</pre>\r\n<p>Если хотя бы одно из этих выражений истинно, то общее условие оператора OR также будет истинно. То есть если или первое условие истинно, или второе.</p></li>\r\n<li><p><span class=\"b\">NOT</span>: операция логического отрицания. Если выражение в этой операции ложно, то общее условие истинно.</p>\r\n<pre class=\"brush:sql;\">NOT выражение</pre>\r\n</li>\r\n</ul>\r\n<p>Например, выберем все товары, у которых производитель Samsung и одновременно цена больше 50000:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' AND Price &gt; 50000;\r\n</pre>\r\n<img src=\"pics/3.8.png\" alt=\"Логический оператор AND в PostgreSQL\">\r\n<p>Теперь изменим оператор на OR. То есть выберем все товары, у которых либо производитель Samsung, либо цена больше 50000:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Price &gt; 50000;\r\n</pre>\r\n<img src=\"pics/3.9.png\" alt=\"Логический оператор OR в PostgreSQL\">\r\n<p>Применение оператора NOT - выберем все товары, у которых производитель не Samsung:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE NOT Manufacturer = 'Samsung';\r\n</pre>\r\n<img src=\"pics/3.10.png\" alt=\"Логический оператор not в PostgreSQL\">\r\n<p>Но в большинстве случае вполне можно обойтись без оператора NOT. Так, в предыдущий пример мы можем переписать следующим образом:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer &lt;&gt; 'Samsung'\r\n</pre>\r\n<p>Также в одной команде SELECT можно использовать сразу несколько операторов:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Price &gt; 30000 AND ProductCount &gt; 2;\r\n</pre>\r\n<p>Так как оператор AND имеет более высокий приоритет, то сначала будет выполняться подвыражение \r\n<code>Price &gt; 30000 AND ProductCount &gt; 2</code>, и только потом оператор OR. \r\nТо есть здесь выбираются товары, которыех на складе больше 2 и у которых одновременно цена больше 30000, либо те товары, \r\nпроизводителем которых является Samsung.</p>\r\n<p>С помощью скобок мы также можем переопределить порядок операций:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE (Manufacturer = 'Samsung' OR Price &gt; 30000) AND ProductCount &gt; 2;\r\n</pre>\r\n<h3>IS NULL</h3>\r\n<p>Ряд столбцов может допускать значение NULL. Это значение не эквивалентно пустой строке ''. NULL представляет полное отсутствие какого-либо значения. \r\nИ для проверки на наличие подобного значения применяется оператор <span class=\"b\">IS NULL</span>.</p>\r\n<p>Например, выберем все товары, у которых не установлено поле ProductCount:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE ProductCount IS NULL;\r\n</pre>\r\n<p>Если, наоборот, необходимо получить строки, у которых поле ProductCount не равно NULL, то можно использовать оператор NOT:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE ProductCount IS NOT NULL;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"3.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"3.4.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/3.4.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 20.03.2018", "title": "Обновление данных. Команда UPDATE", "text": "\n Обновление данных. Команда UPDATE Последнее обновление: 20.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для обновления данных в базе данных PostgreSQL применяется команда  UPDATE . Она имеет следующий общий формальный синтаксис: \r\n \r\nUPDATE имя_таблицы\r\nSET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN\r\n[WHERE условие_обновления]\r\n \r\n Например, увеличим у всех товаров цену на 3000: \r\n \r\nUPDATE Products\r\nSET Price = Price + 3000;\r\n \r\n \r\n В данном случае обновление касается всех строк. С помощью выражения  WHERE  можно с помощью условию конкретизировать обновляемые строки - \r\nесли строка соответствует условию, то она будет обновляться. Например, изменим название производителя с \"Samsung\" на \"Samsung Inc.\": \r\n \r\nUPDATE Products\r\nSET Manufacturer = 'Samsung Inc.'\r\nWHERE Manufacturer = 'Samsung';\r\n \r\n \r\n Также можно обновлять сразу несколько столбцов: \r\n \r\nUPDATE Products\r\nSET Manufacturer = 'Samsung',\r\n\tProductCount = ProductCount + 3\r\nWHERE Manufacturer = 'Samsung Inc.';\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Обновление данных. Команда UPDATE</h2><div class=\"date\">Последнее обновление: 20.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для обновления данных в базе данных PostgreSQL применяется команда <span class=\"b\">UPDATE</span>. Она имеет следующий общий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nUPDATE имя_таблицы\r\nSET столбец1 = значение1, столбец2 = значение2, ... столбецN = значениеN\r\n[WHERE условие_обновления]\r\n</pre>\r\n<p>Например, увеличим у всех товаров цену на 3000:</p>\r\n<pre class=\"brush:sql;\">\r\nUPDATE Products\r\nSET Price = Price + 3000;\r\n</pre>\r\n<img src=\"pics/3.11.png\" alt=\"UPDATE и обновление данных в PostgreSQL\">\r\n<p>В данном случае обновление касается всех строк. С помощью выражения <span class=\"b\">WHERE</span> можно с помощью условию конкретизировать обновляемые строки - \r\nесли строка соответствует условию, то она будет обновляться. Например, изменим название производителя с \"Samsung\" на \"Samsung Inc.\":</p>\r\n<pre class=\"brush:sql;\">\r\nUPDATE Products\r\nSET Manufacturer = 'Samsung Inc.'\r\nWHERE Manufacturer = 'Samsung';\r\n</pre>\r\n<img src=\"pics/3.12.png\" alt=\"UPDATE and WHERE in PostgreSQL\">\r\n<p>Также можно обновлять сразу несколько столбцов:</p>\r\n<pre class=\"brush:sql;\">\r\nUPDATE Products\r\nSET Manufacturer = 'Samsung',\r\n\tProductCount = ProductCount + 3\r\nWHERE Manufacturer = 'Samsung Inc.';\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"3.3.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"3.5.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/3.5.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 20.03.2018", "title": "Удаление данных. Команда DELETE", "text": "\n Удаление данных. Команда DELETE Последнее обновление: 20.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для удаления данных в PostgreSQL применяется команда  DELETE . Она имеет следующий синтаксис: \r\n \r\nDELETE FROM имя_таблицы\r\n[WHERE условие_удаления]\r\n \r\n Например, удалим строки, у которых производитель - Apple: \r\n \r\nDELETE FROM Products\r\nWHERE Manufacturer='Apple';\r\n \r\n \r\n Или удалим все товары, производителем которых является HTC и которые имеют цену меньше 35000: \r\n \r\nDELETE FROM Products\r\nWHERE Manufacturer='HTC' AND Price < 15000;\r\n \r\n Если необходимо вовсе удалить все строки вне зависимости от условия, то условие можно не указывать: \r\n \r\nDELETE FROM Products;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Удаление данных. Команда DELETE</h2><div class=\"date\">Последнее обновление: 20.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для удаления данных в PostgreSQL применяется команда <span class=\"b\">DELETE</span>. Она имеет следующий синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nDELETE FROM имя_таблицы\r\n[WHERE условие_удаления]\r\n</pre>\r\n<p>Например, удалим строки, у которых производитель - Apple:</p>\r\n<pre class=\"brush:sql;\">\r\nDELETE FROM Products\r\nWHERE Manufacturer='Apple';\r\n</pre>\r\n<img src=\"pics/3.13.png\" alt=\"DELETE и удаление данных в PostgreSQL\">\r\n<p>Или удалим все товары, производителем которых является HTC и которые имеют цену меньше 35000:</p>\r\n<pre class=\"brush:sql;\">\r\nDELETE FROM Products\r\nWHERE Manufacturer='HTC' AND Price &lt; 15000;\r\n</pre>\r\n<p>Если необходимо вовсе удалить все строки вне зависимости от условия, то условие можно не указывать:</p>\r\n<pre class=\"brush:sql;\">\r\nDELETE FROM Products;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"3.4.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.1.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 22.03.2018", "title": "DICTINCT. Выборка уникальных значений", "text": "\n Запросы DICTINCT. Выборка уникальных значений Последнее обновление: 22.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор  DISTINCT  позволяет выбрать уникальные данные по определенным столбцам. \r\n Например, в таблице товаров разные товары могут иметь одних и тех же производителей. Например, у нас следующая таблица: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Manufacturer VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC\r\n);\r\nINSERT INTO Products  (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES\r\n('iPhone X', 'Apple', 2, 71000),\r\n('iPhone 8', 'Apple', 3, 56000),\r\n('Galaxy S9', 'Samsung', 6, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 2, 46000),\r\n('Desire 12', 'HTC', 3, 26000);\r\n \r\n Выберем всех производителей: \r\n \r\nSELECT DISTINCT Manufacturer FROM Products;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Запросы</h1><h2>DICTINCT. Выборка уникальных значений</h2><div class=\"date\">Последнее обновление: 22.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор <span class=\"b\">DISTINCT</span> позволяет выбрать уникальные данные по определенным столбцам.</p>\r\n<p>Например, в таблице товаров разные товары могут иметь одних и тех же производителей. Например, у нас следующая таблица:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Manufacturer VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC\r\n);\r\nINSERT INTO Products  (ProductName, Manufacturer, ProductCount, Price)\r\nVALUES\r\n('iPhone X', 'Apple', 2, 71000),\r\n('iPhone 8', 'Apple', 3, 56000),\r\n('Galaxy S9', 'Samsung', 6, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 2, 46000),\r\n('Desire 12', 'HTC', 3, 26000);\r\n</pre>\r\n<p>Выберем всех производителей:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT DISTINCT Manufacturer FROM Products;\r\n</pre>\r\n<img src=\"pics/5.1.png\" alt=\"DISTINCT и выбор уникальных значений в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"3.5.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 22.03.2018", "title": "ORDER BY. Сортировка", "text": "\n ORDER BY. Сортировка Последнее обновление: 22.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор  ORDER BY  позволяет отсортировать значения по определенному столбцу. Например, упорядочим выборку из таблицы Products \r\nпо столбцу ProductCount: \r\n \r\nSELECT * FROM Products\r\nORDER BY ProductCount;\r\n \r\n \r\n Также можно производить упорядочивание данных по псевдониму столбца, который определяется с помощью оператора AS: \r\n \r\nSELECT ProductName, ProductCount * Price AS TotalSum\r\nFROM Products\r\nORDER BY TotalSum;\r\n \r\n \r\n В качестве критерия сортировки также можно использовать сложно выражение на основе столбцов: \r\n \r\nSELECT ProductName, Price, ProductCount\r\nFROM Products\r\nORDER BY ProductCount * Price;\r\n \r\n \r\n Сортировка по убыванию \r\n По умолчанию данные сортируются по возрастанию, однако с помощью оператора  DESC  можно задать сортировку по убыванию. \r\n \r\nSELECT ProductName, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer DESC;\r\n \r\n \r\n По умолчанию вместо DESC используется оператор  ASC , который сортирует по возрастанию: \r\n \r\nSELECT ProductName, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer ASC;\r\n \r\n Сотировка по нескольким столбцам \r\n Если необходимо отсортировать сразу по нескольким столбцам, то все они перечисляются через запятую после оператора  ORDER BY : \r\n \r\nSELECT ProductName, Price, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer, ProductName;\r\n \r\n В этом случае сначала строки сортируются по столбцу Manufacturer по возрастанию. Затем если есть две строки, в которых столбец Manufacturer \r\nимеет одинаковое значение, то они сортируются по столбцу ProductName также по возрастанию. Но опять же с помощью ASC и DESC можно отдельно для \r\nразных столбцов определить сортировку по возрастанию и убыванию: \r\n \r\nSELECT ProductName, Price, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer ASC, ProductName DESC;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>ORDER BY. Сортировка</h2><div class=\"date\">Последнее обновление: 22.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор <span class=\"b\">ORDER BY</span> позволяет отсортировать значения по определенному столбцу. Например, упорядочим выборку из таблицы Products \r\nпо столбцу ProductCount:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nORDER BY ProductCount;\r\n</pre>\r\n<img src=\"pics/5.2.png\" alt=\"order by и сортировка в PostgreSQL\">\r\n<p>Также можно производить упорядочивание данных по псевдониму столбца, который определяется с помощью оператора AS:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, ProductCount * Price AS TotalSum\r\nFROM Products\r\nORDER BY TotalSum;\r\n</pre>\r\n<img src=\"pics/5.3.png\" alt=\"Сортировка по производным столбцам в PostgreSQL\">\r\n<p>В качестве критерия сортировки также можно использовать сложно выражение на основе столбцов:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Price, ProductCount\r\nFROM Products\r\nORDER BY ProductCount * Price;\r\n</pre>\r\n<img src=\"pics/5.6.png\" alt=\"Выражения в ORDER BY в PostgreSQL\">\r\n<h3>Сортировка по убыванию</h3>\r\n<p>По умолчанию данные сортируются по возрастанию, однако с помощью оператора <span class=\"b\">DESC</span> можно задать сортировку по убыванию.</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer DESC;\r\n</pre>\r\n<img src=\"pics/5.4.png\" alt=\"Сортировка по убыванию в PostgreSQL\">\r\n<p>По умолчанию вместо DESC используется оператор <span class=\"b\">ASC</span>, который сортирует по возрастанию:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer ASC;\r\n</pre>\r\n<h3>Сотировка по нескольким столбцам</h3>\r\n<p>Если необходимо отсортировать сразу по нескольким столбцам, то все они перечисляются через запятую после оператора <span class=\"b\">ORDER BY</span>:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Price, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer, ProductName;\r\n</pre>\r\n<p>В этом случае сначала строки сортируются по столбцу Manufacturer по возрастанию. Затем если есть две строки, в которых столбец Manufacturer \r\nимеет одинаковое значение, то они сортируются по столбцу ProductName также по возрастанию. Но опять же с помощью ASC и DESC можно отдельно для \r\nразных столбцов определить сортировку по возрастанию и убыванию:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName, Price, Manufacturer\r\nFROM Products\r\nORDER BY Manufacturer ASC, ProductName DESC;\r\n</pre>\r\n<img src=\"pics/5.5.png\" alt=\"Сортировка по нескольким столбцам в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.3.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.3.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 22.03.2018", "title": "Получение диапазона строк. LIMIT и OFFSET", "text": "\n Получение диапазона строк. LIMIT и OFFSET Последнее обновление: 22.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор LIMIT позволяет извлечь определенное количество строк: \r\n \r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT 4;\r\n \r\n \r\n Оператор  OFFSET  позволяет указать, с какой строки надо начинать выборку. Например, выберем \r\n3 строки, начиная со 2-й: \r\n \r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT 3 OFFSET 2;\r\n \r\n \r\n Если нам надо выбрать вообще все строки, начиная с какой-то определенной, то оператор LIMIT можно опустить: \r\n \r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nOFFSET 2;\r\n \r\n Либо после LIMIT указать ключевое слово  ALL : \r\n \r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT ALL OFFSET 2;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Получение диапазона строк. LIMIT и OFFSET</h2><div class=\"date\">Последнее обновление: 22.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор LIMIT позволяет извлечь определенное количество строк:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT 4;\r\n</pre>\r\n<img src=\"pics/5.7.png\" alt=\"Оператор LIMIT в PostgreSQL\">\r\n<p>Оператор <span class=\"b\">OFFSET</span> позволяет указать, с какой строки надо начинать выборку. Например, выберем \r\n3 строки, начиная со 2-й:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT 3 OFFSET 2;\r\n</pre>\r\n<img src=\"pics/5.8.png\" alt=\"LIMIT и OFFSET в PostgreSQL\">\r\n<p>Если нам надо выбрать вообще все строки, начиная с какой-то определенной, то оператор LIMIT можно опустить:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nOFFSET 2;\r\n</pre>\r\n<p>Либо после LIMIT указать ключевое слово <span class=\"b\">ALL</span>:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nORDER BY ProductName\r\nLIMIT ALL OFFSET 2;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.4.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.4.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 22.03.2018", "title": "Операторы фильтрации", "text": "\n Операторы фильтрации Последнее обновление: 22.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор IN \r\n Оператор  IN  позволяет определить набор значений, которые должны иметь столбцы: \r\n WHERE выражение [NOT] IN (выражение) \r\n Выражение в скобках после IN определяет набор значений. Этот набор может вычисляться динамически на основании, например, еще одного запроса, либо это могут быть константные значения. \r\n Например, выберем товары, у которых производитель либо Samsung, либо Xiaomi, либо Huawei: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer IN ('Samsung', 'HTC', 'Huawei');\r\n \r\n \r\n В качестве алтернативы можно было бы проверить все эти значения через оператор OR: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Manufacturer = 'HTC' OR Manufacturer = 'Huawei';\r\n \r\n Однако использование оператора IN гораздо удобнее, особенно если подобных значений очень много. \r\n С помощью оператора  NOT  можно найти все строки, которые, наоборот, не соответствуют набору значений: \r\n \r\nSELECT * FROM Products\r\nWHERE Manufacturer NOT IN ('Samsung', 'HTC', 'Huawei');\r\n \r\n Оператор BETWEEN \r\n Оператор  BETWEEN  определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать \r\nвыражение: \r\n WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение \r\n Например, получим все товары, у которых цена от 20 000 до 50 000 (начальное и конечное значения также включаются в диапазон): \r\n \r\nSELECT * FROM Products\r\nWHERE Price BETWEEN 20000 AND 50000;\r\n \r\n \r\n Если надо, наоборот, выбрать те строки, которые не попадают в данный диапазон, то применяется оператор NOT: \r\n \r\nSELECT * FROM Products\r\nWHERE Price NOT BETWEEN 20000 AND 50000;\r\n \r\n Также можно использовать более сложные выражения. Например, получим товары, запасы которых на определенную сумму (цена * количество): \r\n \r\nSELECT * FROM Products\r\nWHERE Price * ProductCount BETWEEN 90000 AND 150000;\r\n \r\n Оператор LIKE \r\n Оператор  LIKE  принимает шаблон строки, которому должно соответствовать выражение. \r\n \r\nWHERE выражение [NOT] LIKE шаблон_строки\r\n \r\n Для определения шаблона могут применяться ряд специальных символов подстановки: \r\n \r\n % : соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не \r\nсодержать ни одного символа \r\n Например, выражение  WHERE ProductName LIKE 'Galaxy%'  соответствует таким значениям как \"Galaxy Ace 2\" или \"Galaxy S7\" \r\n _ : соответствует любому одиночному символу \r\n Например, выражение  WHERE ProductName LIKE 'Galaxy S_'  соответствует таким значениям как \"Galaxy S7\" или \"Galaxy S8\". \r\n \r\n Применим оператор LIKE: \r\n \r\nSELECT * FROM Products\r\nWHERE ProductName LIKE 'iPhone%';\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Операторы фильтрации</h2><div class=\"date\">Последнее обновление: 22.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<h3>Оператор IN</h3>\r\n<p>Оператор <span class=\"b\">IN</span> позволяет определить набор значений, которые должны иметь столбцы:</p>\r\n<pre class=\"brush:sql;\">WHERE выражение [NOT] IN (выражение)</pre>\r\n<p>Выражение в скобках после IN определяет набор значений. Этот набор может вычисляться динамически на основании, например, еще одного запроса, либо это могут быть константные значения.</p>\r\n<p>Например, выберем товары, у которых производитель либо Samsung, либо Xiaomi, либо Huawei:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer IN ('Samsung', 'HTC', 'Huawei');\r\n</pre>\r\n<img src=\"pics/5.9.png\" alt=\"Оператор IN в PostgreSQL\">\r\n<p>В качестве алтернативы можно было бы проверить все эти значения через оператор OR:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer = 'Samsung' OR Manufacturer = 'HTC' OR Manufacturer = 'Huawei';\r\n</pre>\r\n<p>Однако использование оператора IN гораздо удобнее, особенно если подобных значений очень много.</p>\r\n<p>С помощью оператора <span class=\"b\">NOT</span> можно найти все строки, которые, наоборот, не соответствуют набору значений:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Manufacturer NOT IN ('Samsung', 'HTC', 'Huawei');\r\n</pre>\r\n<h3>Оператор BETWEEN</h3>\r\n<p>Оператор <span class=\"b\">BETWEEN</span> определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать \r\nвыражение:</p>\r\n<pre class=\"brush:sql;\">WHERE выражение [NOT] BETWEEN начальное_значение AND конечное_значение</pre>\r\n<p>Например, получим все товары, у которых цена от 20 000 до 50 000 (начальное и конечное значения также включаются в диапазон):</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Price BETWEEN 20000 AND 50000;\r\n</pre>\r\n<img src=\"pics/5.10.png\" alt=\"Оператор BETWEEN в PostgreSQL\">\r\n<p>Если надо, наоборот, выбрать те строки, которые не попадают в данный диапазон, то применяется оператор NOT:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Price NOT BETWEEN 20000 AND 50000;\r\n</pre>\r\n<p>Также можно использовать более сложные выражения. Например, получим товары, запасы которых на определенную сумму (цена * количество):</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE Price * ProductCount BETWEEN 90000 AND 150000;\r\n</pre>\r\n<h3>Оператор LIKE</h3>\r\n<p>Оператор <span class=\"b\">LIKE</span> принимает шаблон строки, которому должно соответствовать выражение.</p>\r\n<pre class=\"brush:sql;\">\r\nWHERE выражение [NOT] LIKE шаблон_строки\r\n</pre>\r\n<p>Для определения шаблона могут применяться ряд специальных символов подстановки:</p>\r\n<ul>\r\n<li><p><span class=\"b\">%</span>: соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не \r\nсодержать ни одного символа</p>\r\n<p>Например, выражение <code>WHERE ProductName LIKE 'Galaxy%'</code> соответствует таким значениям как \"Galaxy Ace 2\" или \"Galaxy S7\"</p></li>\r\n<li><p><span class=\"b\">_</span>: соответствует любому одиночному символу</p>\r\n<p>Например, выражение <code>WHERE ProductName LIKE 'Galaxy S_'</code> соответствует таким значениям как \"Galaxy S7\" или \"Galaxy S8\".</p></li>\r\n</ul>\r\n<p>Применим оператор LIKE:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Products\r\nWHERE ProductName LIKE 'iPhone%';\r\n</pre>\r\n<img src=\"pics/5.11.png\" alt=\"Оператор LIKE в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.3.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.5.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.5.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "Агрегатные функции", "text": "\n Агрегатные функции Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Агрегатные функции вычисляют одно значение над некоторым набором строк. В PostgreSQL имеются следующие агрегатные функции: \r\n \r\n AVG : находит среднее значение. Входной параметр должен представлять один из следующих типов:  smallint, int, bigint, real, double \r\nprecision, numeric, interval . Для целочисленнных параметров результатом будет значение типа  numeric , для параметров, которые представляют число с плавающей точкой, - \r\nзначение типа  double precision . \r\n BIT_AND : выполняет операцию побитового умножения (операции логического И) для чисел следующих типов: \r\n smallint, int, bigint, bit . Если параметр содержит значение NULL, то возвращается NULL. \r\n BIT_OR : выполняет операцию побитового сложения (операции логического ИЛИ) для чисел следующих типов: \r\n smallint, int, bigint, bit . Если параметр содержит значение NULL, то возвращается NULL. \r\n BOOL_AND : выполняет операцию логического умножения для значений типа \r\n bool . Если входные все значения равны true, то возвращается true, иначе возвращается false. \r\n BOOL_OR : выполняет операцию логического сложения для значений типа \r\n bool . Если входные хотя бы одно из значений равно true, то возвращается true, иначе возвращается false. \r\n COUNT(*) : находит количество строк в запросе \r\n COUNT(expression) : находит количество строк в запросе, для которых expression не содержит значение NULL. \r\n SUM : находит сумму значений \r\n MIN : находит наименьшее значение \r\n MAX : находит наибольшее значение \r\n STRING_AGG(expression, delimiter) : соединяет с помощью delimiter все текстовые значения из expression в одну строку. \r\n \r\n В качестве параметра все агрегатные функции принимают выражение, которое представляет критерий для определения значений. Зачастую, в качестве \r\nвыражения выступает название столбца, над значениями которого надо проводить вычисления. \r\n Если в наборе нет строк, то все агрегатные функции за исключением  COUNT(*)  возвращают значение NULL. \r\n\r\n Avg \r\n Функция  Avg  возвращает среднее значение на диапазоне значений столбца таблицы. \r\n Пусть в базе данных у нас есть таблица товаров Products, которая описывается следующими выражениями: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INT DEFAULT 0,\r\n    Price NUMERIC NOT NULL,\r\n\tIsDiscounted BOOL\r\n);\r\n  \r\nINSERT INTO Products (ProductName, Company, ProductCount, Price, IsDiscounted) \r\nVALUES\r\n('iPhone X', 'Apple', 3, 76000, false),\r\n('iPhone 8', 'Apple', 2, 71000, true),\r\n('iPhone 7', 'Apple', 5, 42000, true),\r\n('Galaxy S9', 'Samsung', 2, 46000, false),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000, true),\r\n('Desire 12', 'HTC', 5, 28000, true),\r\n('Nokia 9', 'HMD Global', 6, 38000, true);\r\n \r\n Найдем среднюю цену товаров из базы данных: \r\n \r\nSELECT AVG(Price) AS Average_Price FROM Products;\r\n \r\n Для поиска среднего значения в качестве выражения в функцию передается столбец Price. Для получаемого значения устанавливается псевдоним Average_Price, хотя можно его и не \r\nустанавливать. \r\n \r\n Также мы можем применить фильтрацию. Например, найти среднюю цену для товаров какого-то определенного производителя: \r\n \r\nSELECT AVG(Price) FROM Products\r\nWHERE Company='Apple';\r\n \r\n И, кроме того, мы можем находить среднее значение для более сложных выражений. \r\nНапример, найдем среднюю сумму всех товаров, учитывая их количество: \r\n \r\nSELECT AVG(Price * ProductCount) FROM Products\r\n \r\n Count \r\n Функция  Count  вычисляет количество строк в выборке. Есть две формы этой функции. \r\nПервая форма  COUNT(*)  подсчитывает число строк в выборке: \r\n \r\nSELECT COUNT(*) FROM Products;\r\n \r\n \r\n Вторая форма функции вычисляет количество строк по определенному столбцу, при этом строки со значениями NULL игнорируются: \r\n \r\nSELECT COUNT(DISTINCT Company) FROM Products;\r\n \r\n Оператор  DISTINCT  указывает, что надо взять именно уникальные значения из столбца Company. \r\n Min и Max \r\n Функции  Min  и  Max  возвращают соответственно минимальное и максимальное значение по столбцу. \r\nНапример, найдем минимальную цену среди товаров: \r\n \r\nSELECT MIN(Price) FROM Products;\r\n \r\n Поиск максимальной цены: \r\n \r\nSELECT MAX(Price) FROM Products;\r\n \r\n Данные функции также игнорируют значения NULL и не учитывают их при подсчете. \r\n Sum \r\n Функция  Sum  вычисляет сумму значений столбца. Например, подсчитаем общее количество товаров: \r\n \r\nSELECT SUM(ProductCount) FROM Products;\r\n \r\n Также вместо имени столбца может передаваться вычисляемое выражение. Например, найдем общую стоимость всех имеющихся товаров: \r\n \r\nSELECT SUM(ProductCount * Price) FROM Products;\r\n \r\n BOOL_AND и BOOL_OR \r\n Допустим, нам надо узнать, есть ли в таблице товары, которые подлежать скидке, то есть у которых IsDiscounted = true. В этом случае можно \r\nвыполнить функцию  BOOL_OR , которая возвращает true, если хотя бы одно значение в наборе равно true: \r\n SELECT BOOL_OR(IsDiscounted) FROM Products; \r\n Если нам надо узнать, все ли товары подлежат скидке, то можно применить функцию  BOOL_AND , которая возвращает true, если \r\nвсе значения в наборе равны true: \r\n SELECT BOOL_AND(IsDiscounted) FROM Products; \r\n STRING_AGG \r\n Функция  STRING_AGG()  объединяет набор строковых значений или значений bytea. Например, выберем названия всех товаров: \r\n SELECT STRING_AGG(ProductName, ', ') FROM Products; \r\n \r\n Или выберем всех производителей: \r\n \r\nSELECT STRING_AGG(DISTINCT Company, ', ') FROM Products;\r\n\r\n-- результат операции\r\n-- Apple, HMD Global, HTC, Samsung \r\n \r\n Чтобы выбрать уникальных производителей, здесь также применяется оператор  DISTINCT , иначе у нас бы повторялись значения. \r\n Комбинирование функций \r\n Объединим применение нескольких функций: \r\n \r\nSELECT COUNT(*) AS ProdCount,\r\n\t   SUM(ProductCount) AS TotalCount,\r\n       MIN(Price) AS MinPrice,\r\n       MAX(Price) AS MaxPrice,\r\n       AVG(Price) AS AvgPrice\r\nFROM Products;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Агрегатные функции</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Агрегатные функции вычисляют одно значение над некоторым набором строк. В PostgreSQL имеются следующие агрегатные функции:</p>\r\n<ul>\r\n<li><p><span class=\"b\">AVG</span>: находит среднее значение. Входной параметр должен представлять один из следующих типов: <code>smallint, int, bigint, real, double \r\nprecision, numeric, interval</code>. Для целочисленнных параметров результатом будет значение типа <code>numeric</code>, для параметров, которые представляют число с плавающей точкой, - \r\nзначение типа <code>double precision</code>.</p></li>\r\n<li><p><span class=\"b\">BIT_AND</span>: выполняет операцию побитового умножения (операции логического И) для чисел следующих типов: \r\n<code>smallint, int, bigint, bit</code>. Если параметр содержит значение NULL, то возвращается NULL.</p></li>\r\n<li><p><span class=\"b\">BIT_OR</span>: выполняет операцию побитового сложения (операции логического ИЛИ) для чисел следующих типов: \r\n<code>smallint, int, bigint, bit</code>. Если параметр содержит значение NULL, то возвращается NULL.</p></li>\r\n<li><p><span class=\"b\">BOOL_AND</span>: выполняет операцию логического умножения для значений типа \r\n<code>bool</code>. Если входные все значения равны true, то возвращается true, иначе возвращается false.</p></li>\r\n<li><p><span class=\"b\">BOOL_OR</span>: выполняет операцию логического сложения для значений типа \r\n<code>bool</code>. Если входные хотя бы одно из значений равно true, то возвращается true, иначе возвращается false.</p></li>\r\n<li><p><span class=\"b\">COUNT(*)</span>: находит количество строк в запросе</p></li>\r\n<li><p><span class=\"b\">COUNT(expression)</span>: находит количество строк в запросе, для которых expression не содержит значение NULL.</p></li>\r\n<li><p><span class=\"b\">SUM</span>: находит сумму значений</p></li>\r\n<li><p><span class=\"b\">MIN</span>: находит наименьшее значение</p></li>\r\n<li><p><span class=\"b\">MAX</span>: находит наибольшее значение</p></li>\r\n<li><p><span class=\"b\">STRING_AGG(expression, delimiter)</span>: соединяет с помощью delimiter все текстовые значения из expression в одну строку.</p></li>\r\n</ul>\r\n<p>В качестве параметра все агрегатные функции принимают выражение, которое представляет критерий для определения значений. Зачастую, в качестве \r\nвыражения выступает название столбца, над значениями которого надо проводить вычисления.</p>\r\n<p>Если в наборе нет строк, то все агрегатные функции за исключением <code>COUNT(*)</code> возвращают значение NULL.</p>\r\n\r\n<h3>Avg</h3>\r\n<p>Функция <span class=\"b\">Avg</span> возвращает среднее значение на диапазоне значений столбца таблицы.</p>\r\n<p>Пусть в базе данных у нас есть таблица товаров Products, которая описывается следующими выражениями:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INT DEFAULT 0,\r\n    Price NUMERIC NOT NULL,\r\n\tIsDiscounted BOOL\r\n);\r\n  \r\nINSERT INTO Products (ProductName, Company, ProductCount, Price, IsDiscounted) \r\nVALUES\r\n('iPhone X', 'Apple', 3, 76000, false),\r\n('iPhone 8', 'Apple', 2, 71000, true),\r\n('iPhone 7', 'Apple', 5, 42000, true),\r\n('Galaxy S9', 'Samsung', 2, 46000, false),\r\n('Galaxy S8 Plus', 'Samsung', 1, 56000, true),\r\n('Desire 12', 'HTC', 5, 28000, true),\r\n('Nokia 9', 'HMD Global', 6, 38000, true);\r\n</pre>\r\n<p>Найдем среднюю цену товаров из базы данных:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT AVG(Price) AS Average_Price FROM Products;\r\n</pre>\r\n<p>Для поиска среднего значения в качестве выражения в функцию передается столбец Price. Для получаемого значения устанавливается псевдоним Average_Price, хотя можно его и не \r\nустанавливать.</p>\r\n<img src=\"pics/6.1.png\" alt=\"Функция avg в PostgreSQL\">\r\n<p>Также мы можем применить фильтрацию. Например, найти среднюю цену для товаров какого-то определенного производителя:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT AVG(Price) FROM Products\r\nWHERE Company='Apple';\r\n</pre>\r\n<p>И, кроме того, мы можем находить среднее значение для более сложных выражений. \r\nНапример, найдем среднюю сумму всех товаров, учитывая их количество:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT AVG(Price * ProductCount) FROM Products\r\n</pre>\r\n<h3>Count</h3>\r\n<p>Функция <span class=\"b\">Count</span> вычисляет количество строк в выборке. Есть две формы этой функции. \r\nПервая форма <code>COUNT(*)</code> подсчитывает число строк в выборке:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT COUNT(*) FROM Products;\r\n</pre>\r\n<img src=\"pics/6.2.png\" alt=\"Функция count в PostgreSQL\">\r\n<p>Вторая форма функции вычисляет количество строк по определенному столбцу, при этом строки со значениями NULL игнорируются:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT COUNT(DISTINCT Company) FROM Products;\r\n</pre>\r\n<p>Оператор <span class=\"b\">DISTINCT</span> указывает, что надо взять именно уникальные значения из столбца Company.</p>\r\n<h3>Min и Max</h3>\r\n<p>Функции <span class=\"b\">Min</span> и <span class=\"b\">Max</span> возвращают соответственно минимальное и максимальное значение по столбцу. \r\nНапример, найдем минимальную цену среди товаров:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT MIN(Price) FROM Products;\r\n</pre>\r\n<p>Поиск максимальной цены:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT MAX(Price) FROM Products;\r\n</pre>\r\n<p>Данные функции также игнорируют значения NULL и не учитывают их при подсчете.</p>\r\n<h3>Sum</h3>\r\n<p>Функция <span class=\"b\">Sum</span> вычисляет сумму значений столбца. Например, подсчитаем общее количество товаров:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT SUM(ProductCount) FROM Products;\r\n</pre>\r\n<p>Также вместо имени столбца может передаваться вычисляемое выражение. Например, найдем общую стоимость всех имеющихся товаров:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT SUM(ProductCount * Price) FROM Products;\r\n</pre>\r\n<h3>BOOL_AND и BOOL_OR</h3>\r\n<p>Допустим, нам надо узнать, есть ли в таблице товары, которые подлежать скидке, то есть у которых IsDiscounted = true. В этом случае можно \r\nвыполнить функцию <code>BOOL_OR</code>, которая возвращает true, если хотя бы одно значение в наборе равно true:</p>\r\n<pre class=\"brush:sql;\">SELECT BOOL_OR(IsDiscounted) FROM Products;</pre>\r\n<p>Если нам надо узнать, все ли товары подлежат скидке, то можно применить функцию <code>BOOL_AND</code>, которая возвращает true, если \r\nвсе значения в наборе равны true:</p>\r\n<pre class=\"brush:sql;\">SELECT BOOL_AND(IsDiscounted) FROM Products;</pre>\r\n<h3>STRING_AGG</h3>\r\n<p>Функция <span class=\"b\">STRING_AGG()</span> объединяет набор строковых значений или значений bytea. Например, выберем названия всех товаров:</p>\r\n<pre class=\"brush:sql;\">SELECT STRING_AGG(ProductName, ', ') FROM Products;</pre>\r\n<img src=\"pics/6.4.png\" alt=\"Функция string_agg в PostgreSQL\">\r\n<p>Или выберем всех производителей:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT STRING_AGG(DISTINCT Company, ', ') FROM Products;\r\n\r\n-- результат операции\r\n-- Apple, HMD Global, HTC, Samsung \r\n</pre>\r\n<p>Чтобы выбрать уникальных производителей, здесь также применяется оператор <code>DISTINCT</code>, иначе у нас бы повторялись значения.</p>\r\n<h3>Комбинирование функций</h3>\r\n<p>Объединим применение нескольких функций:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT COUNT(*) AS ProdCount,\r\n\t   SUM(ProductCount) AS TotalCount,\r\n       MIN(Price) AS MinPrice,\r\n       MAX(Price) AS MaxPrice,\r\n       AVG(Price) AS AvgPrice\r\nFROM Products;\r\n</pre>\r\n<img src=\"pics/6.3.png\" alt=\"Агрегатные функции в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.4.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.6.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.6.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "Группировка", "text": "\n Группировка Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Для группировки данных в PostgreSQL применяются операторы  GROUP BY  и  HAVING , для использования которых применяется следующий формальный синтаксис: \r\n \r\nSELECT столбцы\r\nFROM таблица\r\n[WHERE условие_фильтрации_строк]\r\n[GROUP BY столбцы_для_группировки]\r\n[HAVING условие_фильтрации_групп]\r\n[ORDER BY столбцы_для_сортировки]\r\n \r\n Для рассмотрения операторов возьмем следующую таблицу: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INT DEFAULT 0,\r\n    Price NUMERIC NOT NULL,\r\n\tIsDiscounted BOOL\r\n);\r\n \r\n GROUP BY \r\n Оператор  GROUP BY  определяет, как строки будут группироваться. \r\n Например, сгруппируем товары по производителю \r\n \r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company;\r\n \r\n Первый столбец в выражении SELECT - Company представляет название группы, а второй столбец - ModelsCount представляет результат функции Count, \r\nкоторая вычисляет количество строк в группе. \r\n \r\n Стоит учитывать, что любой столбец, который используется в выражении SELECT (не считая столбцов, которые хранят результат агрегатных функций), \r\nдолжны быть указаны после оператора GROUP BY. Так, например, в случае выше столбец Company указан и в выражении SELECT, и в выражении \r\nGROUP BY. \r\n И если в выражении SELECT производится выборка по одному или нескольким столбцам и также используются агрегатные функции, то необходимо использовать \r\nвыражение GROUP BY. Так, следующий пример работать не будет, так как он не содержит выражение группировки: \r\n \r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products;\r\n \r\n Другой пример, добавим группировку по количеству товаров: \r\n \r\nSELECT Company, ProductCount, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company, ProductCount;\r\n \r\n Оператор  GROUP BY  может выполнять группировку по множеству столбцов. \r\n Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят \r\nотдельную группу. \r\n Следует учитывать, что выражение  GROUP BY  должно идти после выражения  WHERE , но до выражения \r\n ORDER BY : \r\n \r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nWHERE Price > 30000\r\nGROUP BY Company\r\nORDER BY ModelsCount DESC;\r\n \r\n \r\n Фильтрация групп. HAVING \r\n Оператор  HAVING  указывает, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп. Его использование аналогично применению оператора WHERE. \r\n Например, сгруппируем по производителям и найдем все группы, для которых определено более 1 модели: \r\n \r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company\r\nHAVING COUNT(*) > 1;\r\n \r\n \r\n При этом в одной команде мы можем использовать выражения WHERE и HAVING: \r\n \r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nWHERE Price * ProductCount > 80000\r\nGROUP BY Company\r\nHAVING COUNT(*) > 1;\r\n \r\n То есть в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000. Затем выбранные товары \r\nгруппируются по производителям. И далее фильтруются сами группы - выбираются те группы, которые содержат больше 1 модели. \r\n Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING: \r\n \r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nWHERE Price * ProductCount > 80000\r\nGROUP BY Company\r\nHAVING SUM(ProductCount) > 2\r\nORDER BY Units DESC;\r\n \r\n Здесь группировка идет по производителям, и также выбирается количество моделей для каждого производителя (Models) \r\nи общее количество всех товаров по всем этим моделям (Units). Затем группы сортируются по количеству товаров по убыванию. \r\n \r\n GROUPING SETS, CUBE и ROLLUP \r\n В дополнение к оператору GROUP BY  PostgreSQL поддерживает еще три специальных расширения для группировки данных: \r\n GROUPING SETS ,  ROLLUP  и  CUBE . \r\n GROUPING SETS \r\n Оператор  GROUPING SETS  группирует получемые наборы отдельно: \r\n \r\nSELECT Company, COUNT(*) AS Models, ProductCount\r\nFROM Products\r\nGROUP BY GROUPING SETS(Company, ProductCount);\r\n \r\n В выражении SELECT производится выборка компаний, количества моделей и количества товаров. То есть мы получаем три категории. \r\nОператор GROUPING SETS производит группировку по двум столбцам - Company и ProductCount. В итоге будет создаваться две группы: 1) компании и количество моделей и \r\n2)количество моделей и количество товаров. \r\n \r\n ROLLUP \r\n Оператор  ROLLUP  добавляет суммирующую строку в результирующий набор: \r\n \r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY ROLLUP(Company);\r\n \r\n \r\n Как видно из скриншота, в конце таблицы была добавлена дополнительная строка, которая суммирует значение столбцов. \r\n При группировке по нескольким критериям ROLLUP будет создавать суммирующую строку для каждой из подгрупп: \r\n \r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY ROLLUP(Company, ProductCount)\r\nORDER BY Company;\r\n \r\n \r\n При сортировке с помощью ORDER BY следует учитывать, что она применяется уже после добавления суммирующей строки. \r\n CUBE \r\n CUBE  похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп. \r\n \r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY CUBE(Company, ProductCount);\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Группировка</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Для группировки данных в PostgreSQL применяются операторы <span class=\"b\">GROUP BY</span> и <span class=\"b\">HAVING</span>, для использования которых применяется следующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT столбцы\r\nFROM таблица\r\n[WHERE условие_фильтрации_строк]\r\n[GROUP BY столбцы_для_группировки]\r\n[HAVING условие_фильтрации_групп]\r\n[ORDER BY столбцы_для_сортировки]\r\n</pre>\r\n<p>Для рассмотрения операторов возьмем следующую таблицу:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INT DEFAULT 0,\r\n    Price NUMERIC NOT NULL,\r\n\tIsDiscounted BOOL\r\n);\r\n</pre>\r\n<h3>GROUP BY</h3>\r\n<p>Оператор <span class=\"b\">GROUP BY</span> определяет, как строки будут группироваться.</p>\r\n<p>Например, сгруппируем товары по производителю</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company;\r\n</pre>\r\n<p>Первый столбец в выражении SELECT - Company представляет название группы, а второй столбец - ModelsCount представляет результат функции Count, \r\nкоторая вычисляет количество строк в группе.</p>\r\n<img src=\"pics/6.5.png\" alt=\"Группировка и GROUP BY в PostgreSQL\">\r\n<p>Стоит учитывать, что любой столбец, который используется в выражении SELECT (не считая столбцов, которые хранят результат агрегатных функций), \r\nдолжны быть указаны после оператора GROUP BY. Так, например, в случае выше столбец Company указан и в выражении SELECT, и в выражении \r\nGROUP BY.</p>\r\n<p>И если в выражении SELECT производится выборка по одному или нескольким столбцам и также используются агрегатные функции, то необходимо использовать \r\nвыражение GROUP BY. Так, следующий пример работать не будет, так как он не содержит выражение группировки:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products;\r\n</pre>\r\n<p>Другой пример, добавим группировку по количеству товаров:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, ProductCount, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company, ProductCount;\r\n</pre>\r\n<p>Оператор <code>GROUP BY</code> может выполнять группировку по множеству столбцов.</p>\r\n<p>Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят \r\nотдельную группу.</p>\r\n<p>Следует учитывать, что выражение <code>GROUP BY</code> должно идти после выражения <code>WHERE</code>, но до выражения \r\n<code>ORDER BY</code>:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nWHERE Price &gt; 30000\r\nGROUP BY Company\r\nORDER BY ModelsCount DESC;\r\n</pre>\r\n<img src=\"pics/6.6.png\" alt=\"GROUP BY и сортировка в PostgreSQL\">\r\n<h3>Фильтрация групп. HAVING</h3>\r\n<p>Оператор <span class=\"b\">HAVING</span> указывает, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп. Его использование аналогично применению оператора WHERE.</p>\r\n<p>Например, сгруппируем по производителям и найдем все группы, для которых определено более 1 модели:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nGROUP BY Company\r\nHAVING COUNT(*) &gt; 1;\r\n</pre>\r\n<img src=\"pics/6.7.png\" alt=\"HAVING в PostgreSQL\">\r\n<p>При этом в одной команде мы можем использовать выражения WHERE и HAVING:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS ModelsCount\r\nFROM Products\r\nWHERE Price * ProductCount &gt; 80000\r\nGROUP BY Company\r\nHAVING COUNT(*) &gt; 1;\r\n</pre>\r\n<p>То есть в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000. Затем выбранные товары \r\nгруппируются по производителям. И далее фильтруются сами группы - выбираются те группы, которые содержат больше 1 модели.</p>\r\n<p>Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nWHERE Price * ProductCount &gt; 80000\r\nGROUP BY Company\r\nHAVING SUM(ProductCount) &gt; 2\r\nORDER BY Units DESC;\r\n</pre>\r\n<p>Здесь группировка идет по производителям, и также выбирается количество моделей для каждого производителя (Models) \r\nи общее количество всех товаров по всем этим моделям (Units). Затем группы сортируются по количеству товаров по убыванию.</p>\r\n<img src=\"pics/6.8.png\" alt=\"HAVING с фильтрацией и сортировкой в PostgreSQL\">\r\n<h3>GROUPING SETS, CUBE и ROLLUP</h3>\r\n<p>В дополнение к оператору GROUP BY  PostgreSQL поддерживает еще три специальных расширения для группировки данных: \r\n<span class=\"b\">GROUPING SETS</span>, <span class=\"b\">ROLLUP</span> и <span class=\"b\">CUBE</span>.</p>\r\n<h4>GROUPING SETS</h4>\r\n<p>Оператор <span class=\"b\">GROUPING SETS</span> группирует получемые наборы отдельно:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS Models, ProductCount\r\nFROM Products\r\nGROUP BY GROUPING SETS(Company, ProductCount);\r\n</pre>\r\n<p>В выражении SELECT производится выборка компаний, количества моделей и количества товаров. То есть мы получаем три категории. \r\nОператор GROUPING SETS производит группировку по двум столбцам - Company и ProductCount. В итоге будет создаваться две группы: 1) компании и количество моделей и \r\n2)количество моделей и количество товаров.</p>\r\n<img src=\"pics/6.8.png\" alt=\"GROUPING SETS in PostgreSQL\">\r\n<h4>ROLLUP</h4>\r\n<p>Оператор <span class=\"b\">ROLLUP</span> добавляет суммирующую строку в результирующий набор:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY ROLLUP(Company);\r\n</pre>\r\n<img src=\"pics/6.9.png\" alt=\"Оператор ROLLUP в PostgreSQL\">\r\n<p>Как видно из скриншота, в конце таблицы была добавлена дополнительная строка, которая суммирует значение столбцов.</p>\r\n<p>При группировке по нескольким критериям ROLLUP будет создавать суммирующую строку для каждой из подгрупп:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY ROLLUP(Company, ProductCount)\r\nORDER BY Company;\r\n</pre>\r\n<img src=\"pics/6.10.png\" alt=\"WITH ROLLUP in PostgreSQL\">\r\n<p>При сортировке с помощью ORDER BY следует учитывать, что она применяется уже после добавления суммирующей строки.</p>\r\n<h4>CUBE</h4>\r\n<p><span class=\"b\">CUBE</span> похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп.</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Company, COUNT(*) AS Models, SUM(ProductCount) AS Units\r\nFROM Products\r\nGROUP BY CUBE(Company, ProductCount);\r\n</pre>\r\n<img src=\"pics/6.11.png\" alt=\"CUBE in PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.5.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"4.7.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/4.7.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "Подзапросы", "text": "\n Подзапросы Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы. \r\n Например, определим таблицы для товаров, покупателей и заказов: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n \r\n Таблица Orders содержит ссылки на две другие таблицы через поля ProductId и CustomerId. \r\n Добавим в эти таблицы некоторые данные: \r\n \r\nINSERT INTO Products(ProductName, Company, ProductCount, Price) \r\nVALUES ('iPhone X', 'Apple', 2, 66000),\r\n('iPhone 8', 'Apple', 2, 51000),\r\n('iPhone 7', 'Apple', 5, 42000),\r\n('Galaxy S9', 'Samsung', 2, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 46000),\r\n('Nokia 9', 'HDM Global', 2, 26000),\r\n('Desire 12', 'HTC', 6, 38000);\r\n \r\nINSERT INTO Customers(FirstName) \r\nVALUES ('Tom'), ('Bob'),('Sam');\r\n \r\nINSERT INTO Orders(ProductId, CustomerId, CreatedAt, ProductCount, Price) \r\nVALUES\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='Galaxy S9'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-11',  \r\n    2, \r\n    (SELECT Price FROM Products WHERE ProductName='Galaxy S9')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-13',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Bob'),\r\n    '2017-07-11',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n);\r\n \r\n При добавлении данных в таблицу Orders как раз используются подзапросы. Например, первый заказ был сделан покупателем Tom на товар Galaxy S9. \r\nПоэтому в таблицу Orders необходимо сохранить информацию о заказе, где поле ProductId указывает на Id товара Galaxy S9, поле Price - на его цену, а поле \r\nCustomerId - на Id покупателя Tom. Но на момент написания запроса нам может быть неизвестен ни Id покупателя, ни Id товара, ни цена товара. \r\nВ этом случае можно выполнить подзапрос. \r\n Подзапрос представляет команду SELECT и заключается в скобки. В данном же случае при добавлении одного товара выполняется три подзапроса. \r\nКаждый подзапрос возвращает одно скалярное значение, например, идентификатор товара или покупателя. \r\n В данном случае подзапросы выполнялись к другой таблице, но могут выполняться и к той же, к которой вызывается основной запрос. Например, найдем \r\nтовары из таблицы Products, которые имеют минимальную цену: \r\n \r\nSELECT *\r\nFROM Products\r\nWHERE Price = (SELECT MIN(Price) FROM Products);\r\n \r\n Или найдем товары, цена которых выше средней: \r\n \r\nSELECT *\r\nFROM Products\r\nWHERE Price > (SELECT AVG(Price) FROM Products);\r\n \r\n \r\n Коррелирующие подзапросы \r\n Подзапросы бывают коррелирующими и некоррелирующими. В примерах выше команды SELECT выполняли фактически один подзапрос для всей команды, \r\nнапример, подзапрос возвращает минимальную или среднюю цену, которая не изменится, сколько бы мы строк не выбирали в основном запросе. \r\nРезультат такого подзапроса не зависел от строк, которые выбираются в основном запросе. И такой подзапрос выполняется один раз для всего \r\nвнешнего запроса. \r\n Но кроме того есть  коррелирующие подзапросы  (correlated subquery), результаты которых зависят от строк, \r\nкоторые извлекаются в основном запросе. \r\n Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре: \r\n \r\nSELECT  CreatedAt, \r\n\t\tPrice, \r\n\t\t(SELECT ProductName FROM Products \r\n\t\tWHERE Products.Id = Orders.ProductId) AS Product\r\nFROM Orders;\r\n \r\n Здесь для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId. И каждый подзапрос может возвращать различные данные. \r\n \r\n Коррелирующий подзапрос может выполняться и для той же таблицы, к которой выполняется основной запрос. \r\nНапример, выберем из таблицы Products те товары, стоимость которых выше средней цены товаров для данного производителя: \r\n \r\nSELECT ProductName,\r\n\t   Company,\r\n\t   Price, \r\n\t\t(SELECT AVG(Price) FROM Products AS SubProds \r\n\t\t WHERE SubProds.Company=Prods.Company)  AS AvgPrice\r\nFROM Products AS Prods\r\nWHERE Price > \r\n\t(SELECT AVG(Price) FROM Products AS SubProds \r\n\t WHERE SubProds.Company=Prods.Company)\r\n \r\n \r\n В данном случае определено два коррелирующих подзапроса. Первый подзапрос определяет спецификацию столбца AvgPrice. \r\nОн будет выполняться для каждой строки, извлекаемой из таблицы Products. В подзапрос передается производитель товара и на его основе выбирается \r\nсредняя цена для товаров именно этого производителя. И так как производитель у товаров может отличаться, то и результат подзапроса в каждом случае также может отличаться. \r\n Второй подзапрос аналогичен, только он используется для фильтрации извлекаемых из таблицы Products. И также он будет выполняться для каждой строки. \r\n Чтобы избежать двойственности при фильтрации в подзапросе при сравнении производителей ( SubProds.Company=Prods.Company ) для внешней выборки установлен псевдоним Prods, а для выборки из подзапросов определен псевдоним \r\nSubProds. \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Подзапросы</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы.</p>\r\n<p>Например, определим таблицы для товаров, покупателей и заказов:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n</pre>\r\n<p>Таблица Orders содержит ссылки на две другие таблицы через поля ProductId и CustomerId.</p>\r\n<p>Добавим в эти таблицы некоторые данные:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products(ProductName, Company, ProductCount, Price) \r\nVALUES ('iPhone X', 'Apple', 2, 66000),\r\n('iPhone 8', 'Apple', 2, 51000),\r\n('iPhone 7', 'Apple', 5, 42000),\r\n('Galaxy S9', 'Samsung', 2, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 46000),\r\n('Nokia 9', 'HDM Global', 2, 26000),\r\n('Desire 12', 'HTC', 6, 38000);\r\n \r\nINSERT INTO Customers(FirstName) \r\nVALUES ('Tom'), ('Bob'),('Sam');\r\n \r\nINSERT INTO Orders(ProductId, CustomerId, CreatedAt, ProductCount, Price) \r\nVALUES\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='Galaxy S9'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-11',  \r\n    2, \r\n    (SELECT Price FROM Products WHERE ProductName='Galaxy S9')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-13',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Bob'),\r\n    '2017-07-11',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n);\r\n</pre>\r\n<p>При добавлении данных в таблицу Orders как раз используются подзапросы. Например, первый заказ был сделан покупателем Tom на товар Galaxy S9. \r\nПоэтому в таблицу Orders необходимо сохранить информацию о заказе, где поле ProductId указывает на Id товара Galaxy S9, поле Price - на его цену, а поле \r\nCustomerId - на Id покупателя Tom. Но на момент написания запроса нам может быть неизвестен ни Id покупателя, ни Id товара, ни цена товара. \r\nВ этом случае можно выполнить подзапрос.</p>\r\n<p>Подзапрос представляет команду SELECT и заключается в скобки. В данном же случае при добавлении одного товара выполняется три подзапроса. \r\nКаждый подзапрос возвращает одно скалярное значение, например, идентификатор товара или покупателя.</p>\r\n<p>В данном случае подзапросы выполнялись к другой таблице, но могут выполняться и к той же, к которой вызывается основной запрос. Например, найдем \r\nтовары из таблицы Products, которые имеют минимальную цену:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT *\r\nFROM Products\r\nWHERE Price = (SELECT MIN(Price) FROM Products);\r\n</pre>\r\n<p>Или найдем товары, цена которых выше средней:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT *\r\nFROM Products\r\nWHERE Price &gt; (SELECT AVG(Price) FROM Products);\r\n</pre>\r\n<img src=\"pics/7.1.png\" alt=\"Подзапросы в PostgreSQL\">\r\n<h3>Коррелирующие подзапросы</h3>\r\n<p>Подзапросы бывают коррелирующими и некоррелирующими. В примерах выше команды SELECT выполняли фактически один подзапрос для всей команды, \r\nнапример, подзапрос возвращает минимальную или среднюю цену, которая не изменится, сколько бы мы строк не выбирали в основном запросе. \r\nРезультат такого подзапроса не зависел от строк, которые выбираются в основном запросе. И такой подзапрос выполняется один раз для всего \r\nвнешнего запроса.</p>\r\n<p>Но кроме того есть <span class=\"b\">коррелирующие подзапросы</span> (correlated subquery), результаты которых зависят от строк, \r\nкоторые извлекаются в основном запросе.</p>\r\n<p>Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT  CreatedAt, \r\n\t\tPrice, \r\n\t\t(SELECT ProductName FROM Products \r\n\t\tWHERE Products.Id = Orders.ProductId) AS Product\r\nFROM Orders;\r\n</pre>\r\n<p>Здесь для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId. И каждый подзапрос может возвращать различные данные.</p>\r\n<img src=\"pics/7.2.png\" alt=\"Correlated subquery in PostgreSQL\">\r\n<p>Коррелирующий подзапрос может выполняться и для той же таблицы, к которой выполняется основной запрос. \r\nНапример, выберем из таблицы Products те товары, стоимость которых выше средней цены товаров для данного производителя:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT ProductName,\r\n\t   Company,\r\n\t   Price, \r\n\t\t(SELECT AVG(Price) FROM Products AS SubProds \r\n\t\t WHERE SubProds.Company=Prods.Company)  AS AvgPrice\r\nFROM Products AS Prods\r\nWHERE Price &gt; \r\n\t(SELECT AVG(Price) FROM Products AS SubProds \r\n\t WHERE SubProds.Company=Prods.Company)\r\n</pre>\r\n<img src=\"pics/7.3.png\" alt=\"Коррелирующий подзапрос в PostgreSQL\">\r\n<p>В данном случае определено два коррелирующих подзапроса. Первый подзапрос определяет спецификацию столбца AvgPrice. \r\nОн будет выполняться для каждой строки, извлекаемой из таблицы Products. В подзапрос передается производитель товара и на его основе выбирается \r\nсредняя цена для товаров именно этого производителя. И так как производитель у товаров может отличаться, то и результат подзапроса в каждом случае также может отличаться.</p>\r\n<p>Второй подзапрос аналогичен, только он используется для фильтрации извлекаемых из таблицы Products. И также он будет выполняться для каждой строки.</p>\r\n<p>Чтобы избежать двойственности при фильтрации в подзапросе при сравнении производителей (<code>SubProds.Company=Prods.Company</code>) для внешней выборки установлен псевдоним Prods, а для выборки из подзапросов определен псевдоним \r\nSubProds.</p>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.6.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"5.1.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/5.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 22.03.2018", "title": "Массивы", "text": "\n Составные типы данных Массивы Последнее обновление: 22.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Столбцы в таблице в PostgreSQL могут представлять массивы, например, массивы чисел INTEGER или массивы строк VARCHAR или массивы других типов данных. \r\nРассмотрим, как работать с массивами в PostgreSQL. \r\n Вначале определим простейшую таблицу: \r\n \r\ncreate table posts(\r\n\tid serial primary key,\r\n\ttitle varchar(30),\r\n\tbody text,\r\n\ttags varchar(10)[]\r\n);\r\n \r\n Таблица posts будет хранить условные статьи, где столбец title хранит заголовок статьи, body - ее текст, а tags - список тегов статьи. \r\nПричем столбец tags представляет массив данных varchar(10), то есть строк. Для определения массива после названия типа указываются квадратные скобки. \r\n Добавим в эту таблицу одну статью с набором тегов: \r\n \r\ninsert into posts(title, body, tags)\r\nvalues('Post Title', 'Post Text', '{\"sql\", \"postgres\", \"database\", \"plsql\"}');\r\n \r\n \r\n Массив определяется в кавычках, как и строка, но внутри кавычек все элементы массива помещаются в фигурные скобки. Каждый отдельный элемент массива \r\nзаключается в двойные кавычки. То есть в данном случае в массиве четыре элемента: \"sql\", \"postgres\", \"database\" и \"plsql\". \r\n Как и данные любого другого столбца, мы можем извлечь данные массива: \r\n \r\nselect tags from posts;\r\n \r\n Однако с помощью индексов мы также можем конкретизировать, какие именно элементы массива мы хотим получить: \r\n \r\nselect tags[0:3] from posts;\r\n \r\n Индексы указываются в скобках через двоеточие. Вначале идет индекс начала диапазона, а затем индекс конца диапазона. То есть в данном случае \r\nизвлекаем три тега с первого по третий. \r\n \r\n При обновлении строки мы можем изменять как в целом все теги, так и какие-то конкретные теги. Например, удалим все теги: \r\n \r\nupdate posts \r\nset tags='{}' \r\nwhere id=1;\r\n \r\n Переустановим массив: \r\n \r\nupdate posts \r\nset tags='{\"sql\", \"postgres\", \"database\"}' \r\nwhere id=1;\r\n \r\n Переустановим конкретный элемент, например, второй: \r\n \r\nupdate posts \r\nset tags[2]='system' \r\nwhere id=1;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Составные типы данных</h1><h2>Массивы</h2><div class=\"date\">Последнее обновление: 22.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Столбцы в таблице в PostgreSQL могут представлять массивы, например, массивы чисел INTEGER или массивы строк VARCHAR или массивы других типов данных. \r\nРассмотрим, как работать с массивами в PostgreSQL.</p>\r\n<p>Вначале определим простейшую таблицу:</p>\r\n<pre class=\"brush:sql;\">\r\ncreate table posts(\r\n\tid serial primary key,\r\n\ttitle varchar(30),\r\n\tbody text,\r\n\ttags varchar(10)[]\r\n);\r\n</pre>\r\n<p>Таблица posts будет хранить условные статьи, где столбец title хранит заголовок статьи, body - ее текст, а tags - список тегов статьи. \r\nПричем столбец tags представляет массив данных varchar(10), то есть строк. Для определения массива после названия типа указываются квадратные скобки.</p>\r\n<p>Добавим в эту таблицу одну статью с набором тегов:</p>\r\n<pre class=\"brush:sql;\">\r\ninsert into posts(title, body, tags)\r\nvalues('Post Title', 'Post Text', '{\"sql\", \"postgres\", \"database\", \"plsql\"}');\r\n</pre>\r\n<img src=\"pics/4.1.png\" alt=\"Массивы в PostgreSQL\">\r\n<p>Массив определяется в кавычках, как и строка, но внутри кавычек все элементы массива помещаются в фигурные скобки. Каждый отдельный элемент массива \r\nзаключается в двойные кавычки. То есть в данном случае в массиве четыре элемента: \"sql\", \"postgres\", \"database\" и \"plsql\".</p>\r\n<p>Как и данные любого другого столбца, мы можем извлечь данные массива:</p>\r\n<pre class=\"brush:sql;\">\r\nselect tags from posts;\r\n</pre>\r\n<p>Однако с помощью индексов мы также можем конкретизировать, какие именно элементы массива мы хотим получить:</p>\r\n<pre class=\"brush:sql;\">\r\nselect tags[0:3] from posts;\r\n</pre>\r\n<p>Индексы указываются в скобках через двоеточие. Вначале идет индекс начала диапазона, а затем индекс конца диапазона. То есть в данном случае \r\nизвлекаем три тега с первого по третий.</p>\r\n<img src=\"pics/4.2.png\" alt=\"Arrays in PostgreSQL\">\r\n<p>При обновлении строки мы можем изменять как в целом все теги, так и какие-то конкретные теги. Например, удалим все теги:</p>\r\n<pre class=\"brush:sql;\">\r\nupdate posts \r\nset tags='{}' \r\nwhere id=1;\r\n</pre>\r\n<p>Переустановим массив:</p>\r\n<pre class=\"brush:sql;\">\r\nupdate posts \r\nset tags='{\"sql\", \"postgres\", \"database\"}' \r\nwhere id=1;\r\n</pre>\r\n<p>Переустановим конкретный элемент, например, второй:</p>\r\n<pre class=\"brush:sql;\">\r\nupdate posts \r\nset tags[2]='system' \r\nwhere id=1;\r\n</pre>\r\n<img src=\"pics/4.3.png\" alt=\"Обновление массива в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"4.7.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"5.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/5.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 21.03.2018", "title": "Перечисления enum", "text": "\n Перечисления enum Последнее обновление: 21.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n PostgreSQL имеет специальный тип данных, который называется  enum  и который представляет набор констант. И столбец подобного типа может \r\nв качестве значения принимать одну из этих констант. Рассмотрим, как использовать перечисления. \r\n Для создания перечисления используется команда  CREATE TYPE . Например, создадим простейшее перечисление: \r\n \r\ncreate type request_state as enum ('created', 'approved', 'finshed');\r\n \r\n Данное перечисление называется \"request_state\". После слова  enum  в скобках указывается через запятую список констант, \r\nкоторые составляют данное перечисление. То есть в данном случае перечисление request_status может принимать три значения: 'created', 'approved', 'finshed'. \r\n После создания перечисления мы можем использовать его в качестве типа столбца. Например, создадим следующую таблицу: \r\n \r\ncreate table requests(\r\n\tid serial primary key,\r\n\ttitle varchar(30),\r\n\tstatus request_state\r\n);\r\n \r\n Здесь третий столбец - status представляет перечисление request_state и может принимать одно из трех выше указанных значений. \r\nПоэтому при добавлении данных нужно указать для данного столбца одно из этих трех значений: \r\n \r\ninsert into requests(title, status)\r\nvalues ('Request 1', 'created');\r\n \r\n При этом важно, что столбец может иметь только одно из этих трех значений, а не какие-то произвольные значения. Кроме того, большую роль играет регистр символов, \r\nнапример, \"created\" не эквивалентно \"Created\". \r\n \r\n При обновлении данных также необходиом предоставить одно из значений перечисления: \r\n \r\nupdate requests \r\nset status='approved' \r\nwhere id=1;\r\n \r\n Изменение перечисления \r\n После создания перечисления вполне возможно нам захочется его изменить, например, добавить новое значение. \r\nДля этого применяется команда  ALTER TYPE . \r\n Добавление нового значения: \r\n \r\nALTER TYPE request_state ADD VALUE 'blocked';\r\n \r\n К сожалению, удалить так просто уже имеющееся значение из перечисления не получится. В этому случае \r\nмы можем создать новое перечисление и указать, чтобы таблица использовала именно новое перечисление: \r\n \r\nCREATE TYPE status_enum AS ENUM('created', 'approved', 'done');\r\n\r\nALTER TABLE requests ALTER COLUMN status TYPE status_enum \r\nUSING status::text::status_enum;\r\n \r\n Удаление \r\n Если перечисление больше не нужно, то с помощью команды  DROP TYPE  его можно удалить: \r\n DROP TYPE request_state; \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Перечисления enum</h2><div class=\"date\">Последнее обновление: 21.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>PostgreSQL имеет специальный тип данных, который называется <span class=\"b\">enum</span> и который представляет набор констант. И столбец подобного типа может \r\nв качестве значения принимать одну из этих констант. Рассмотрим, как использовать перечисления.</p>\r\n<p>Для создания перечисления используется команда <span class=\"b\">CREATE TYPE</span>. Например, создадим простейшее перечисление:</p>\r\n<pre class=\"brush:sql;\">\r\ncreate type request_state as enum ('created', 'approved', 'finshed');\r\n</pre>\r\n<p>Данное перечисление называется \"request_state\". После слова <span class=\"b\">enum</span> в скобках указывается через запятую список констант, \r\nкоторые составляют данное перечисление. То есть в данном случае перечисление request_status может принимать три значения: 'created', 'approved', 'finshed'.</p>\r\n<p>После создания перечисления мы можем использовать его в качестве типа столбца. Например, создадим следующую таблицу:</p>\r\n<pre class=\"brush:sql;\">\r\ncreate table requests(\r\n\tid serial primary key,\r\n\ttitle varchar(30),\r\n\tstatus request_state\r\n);\r\n</pre>\r\n<p>Здесь третий столбец - status представляет перечисление request_state и может принимать одно из трех выше указанных значений. \r\nПоэтому при добавлении данных нужно указать для данного столбца одно из этих трех значений:</p>\r\n<pre class=\"brush:sql;\">\r\ninsert into requests(title, status)\r\nvalues ('Request 1', 'created');\r\n</pre>\r\n<p>При этом важно, что столбец может иметь только одно из этих трех значений, а не какие-то произвольные значения. Кроме того, большую роль играет регистр символов, \r\nнапример, \"created\" не эквивалентно \"Created\".</p>\r\n<img src=\"pics/4.4.png\" alt=\"Перечисления в PostgreSQL\">\r\n<p>При обновлении данных также необходиом предоставить одно из значений перечисления:</p>\r\n<pre class=\"brush:sql;\">\r\nupdate requests \r\nset status='approved' \r\nwhere id=1;\r\n</pre>\r\n<h3>Изменение перечисления</h3>\r\n<p>После создания перечисления вполне возможно нам захочется его изменить, например, добавить новое значение. \r\nДля этого применяется команда <span class=\"b\">ALTER TYPE</span>.</p>\r\n<p>Добавление нового значения:</p>\r\n<pre class=\"brush:sql;\">\r\nALTER TYPE request_state ADD VALUE 'blocked';\r\n</pre>\r\n<p>К сожалению, удалить так просто уже имеющееся значение из перечисления не получится. В этому случае \r\nмы можем создать новое перечисление и указать, чтобы таблица использовала именно новое перечисление:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TYPE status_enum AS ENUM('created', 'approved', 'done');\r\n\r\nALTER TABLE requests ALTER COLUMN status TYPE status_enum \r\nUSING status::text::status_enum;\r\n</pre>\r\n<h3>Удаление</h3>\r\n<p>Если перечисление больше не нужно, то с помощью команды <span class=\"b\">DROP TYPE</span> его можно удалить:</p>\r\n<pre class=\"brush:sql;\">DROP TYPE request_state;</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"5.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.1.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.1.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "Неявное соединение таблиц", "text": "\n Соединение таблиц Неявное соединение таблиц Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Нередко возникает ситуация, когда нам надо получить данные из нескольких таблиц. \r\nДля соединения данных из разных таблиц можно использовать команду SELECT. Например, пусть имеются следующие таблицы, которые связаны \r\nмежду собой связями: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n \r\n В данном случае таблицы Customers и Products связаны с таблицей Orders связью один ко многим. Таблица Orders в виде внешних ключей ProductId и CustomerId \r\nсодержит ссылки на столбцы Id из соответственно таблиц Products и Customers. Также она хранит количество купленного товара (ProductCount) \r\nи и по какой цене он был куплен (Price). И кроме того, таблицы также хранит в виде столбца CreatedAt дату покупки. \r\n Пусть эти таблицы будут содержать следующие данные: \r\n \r\nINSERT INTO Products(ProductName, Company, ProductCount, Price) \r\nVALUES ('iPhone X', 'Apple', 2, 66000),\r\n('iPhone 8', 'Apple', 2, 51000),\r\n('iPhone 7', 'Apple', 5, 42000),\r\n('Galaxy S9', 'Samsung', 2, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 46000),\r\n('Nokia 9', 'HDM Global', 2, 26000),\r\n('Desire 12', 'HTC', 6, 38000);\r\n \r\nINSERT INTO Customers(FirstName) \r\nVALUES ('Tom'), ('Bob'),('Sam');\r\n \r\nINSERT INTO Orders(ProductId, CustomerId, CreatedAt, ProductCount, Price) \r\nVALUES\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='Galaxy S9'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-11',  \r\n    2, \r\n    (SELECT Price FROM Products WHERE ProductName='Galaxy S9')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-13',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Bob'),\r\n    '2017-07-11',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n);\r\n \r\n Теперь соединим две таблицы Orders и Customers: \r\n \r\nSELECT * FROM Orders, Customers;\r\n \r\n При такой выборке для каждая строка из таблицы Orders будет совмещаться с каждой строкой из таблицы Customers. То есть, получится перекрестное соединение. \r\nНапример, в Orders три строки, а в Customers то же три строки, значит мы получим 3 * 3 = 9 строк: \r\n  \r\n То есть в данном случае мы получаем прямое (декартово) произведение двух групп. Однако вряд ли такой результат можно назвать желаемым. \r\nТем более каждый заказ из Orders связан с конкретным покупателем из Customers, а не со всеми возможными покупателями. \r\n Для решения этой задачи необходимо использовать выражение  WHERE  и фильтровать строки при условии, что поле CustomerId из Orders соответствует полю Id из Customers: \r\n \r\nSELECT * FROM Orders, Customers\r\nWHERE Orders.CustomerId = Customers.Id;\r\n \r\n \r\n Теперь объединим данные по трем таблицам Orders, Customers и Proucts. То есть получим все заказы и добавим информацию по клиенту и связанному товару: \r\n \r\nSELECT Customers.FirstName, Products.ProductName, Orders.CreatedAt \r\nFROM Orders, Customers, Products\r\nWHERE Orders.CustomerId = Customers.Id AND Orders.ProductId=Products.Id;\r\n \r\n Так как здесь соединяются три таблицы, то необходимо применить как минимум два условия. Ключевой таблицей остается Orders, из которой \r\nизвлекаются все заказы, а затем к ней подсоединяются данные по клиенту по условию  Orders.CustomerId = Customers.Id  и данные по товару по условию  Orders.ProductId=Products.Id \r\n \r\n Поскольку в данном случае названия таблиц сильно увеличивают код, то мы его можем сократить за счет использования псевдонимов таблиц: \r\n \r\nSELECT C.FirstName, P.ProductName, O.CreatedAt \r\nFROM Orders AS O, Customers AS C, Products AS P\r\nWHERE O.CustomerId = C.Id AND O.ProductId=P.Id;\r\n \r\n Если необходимо при использовании псевдонима выбрать все столбцы из определенной таблицы, то можно использовать звездочку: \r\n \r\nSELECT C.FirstName, P.ProductName, O.*\r\nFROM Orders AS O, Customers AS C, Products AS P\r\nWHERE O.CustomerId = C.Id AND O.ProductId=P.Id;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h1>Соединение таблиц</h1><h2>Неявное соединение таблиц</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Нередко возникает ситуация, когда нам надо получить данные из нескольких таблиц. \r\nДля соединения данных из разных таблиц можно использовать команду SELECT. Например, пусть имеются следующие таблицы, которые связаны \r\nмежду собой связями:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n</pre>\r\n<p>В данном случае таблицы Customers и Products связаны с таблицей Orders связью один ко многим. Таблица Orders в виде внешних ключей ProductId и CustomerId \r\nсодержит ссылки на столбцы Id из соответственно таблиц Products и Customers. Также она хранит количество купленного товара (ProductCount) \r\nи и по какой цене он был куплен (Price). И кроме того, таблицы также хранит в виде столбца CreatedAt дату покупки.</p>\r\n<p>Пусть эти таблицы будут содержать следующие данные:</p>\r\n<pre class=\"brush:sql;\">\r\nINSERT INTO Products(ProductName, Company, ProductCount, Price) \r\nVALUES ('iPhone X', 'Apple', 2, 66000),\r\n('iPhone 8', 'Apple', 2, 51000),\r\n('iPhone 7', 'Apple', 5, 42000),\r\n('Galaxy S9', 'Samsung', 2, 56000),\r\n('Galaxy S8 Plus', 'Samsung', 1, 46000),\r\n('Nokia 9', 'HDM Global', 2, 26000),\r\n('Desire 12', 'HTC', 6, 38000);\r\n \r\nINSERT INTO Customers(FirstName) \r\nVALUES ('Tom'), ('Bob'),('Sam');\r\n \r\nINSERT INTO Orders(ProductId, CustomerId, CreatedAt, ProductCount, Price) \r\nVALUES\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='Galaxy S9'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-11',  \r\n    2, \r\n    (SELECT Price FROM Products WHERE ProductName='Galaxy S9')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Tom'),\r\n    '2017-07-13',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n),\r\n( \r\n    (SELECT Id FROM Products WHERE ProductName='iPhone 8'), \r\n    (SELECT Id FROM Customers WHERE FirstName='Bob'),\r\n    '2017-07-11',  \r\n    1, \r\n    (SELECT Price FROM Products WHERE ProductName='iPhone 8')\r\n);\r\n</pre>\r\n<p>Теперь соединим две таблицы Orders и Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Orders, Customers;\r\n</pre>\r\n<p>При такой выборке для каждая строка из таблицы Orders будет совмещаться с каждой строкой из таблицы Customers. То есть, получится перекрестное соединение. \r\nНапример, в Orders три строки, а в Customers то же три строки, значит мы получим 3 * 3 = 9 строк:</p>\r\n <img src=\"pics/8.1.png\" alt=\"Неявное соединение таблиц без JOIN в PostgreSQL\">\r\n<p>То есть в данном случае мы получаем прямое (декартово) произведение двух групп. Однако вряд ли такой результат можно назвать желаемым. \r\nТем более каждый заказ из Orders связан с конкретным покупателем из Customers, а не со всеми возможными покупателями.</p>\r\n<p>Для решения этой задачи необходимо использовать выражение <span class=\"b\">WHERE</span> и фильтровать строки при условии, что поле CustomerId из Orders соответствует полю Id из Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Orders, Customers\r\nWHERE Orders.CustomerId = Customers.Id;\r\n</pre>\r\n<img src=\"pics/8.2.png\" alt=\"Соединение таблиц с помощью SELECT в PostgreSQL\">\r\n<p>Теперь объединим данные по трем таблицам Orders, Customers и Proucts. То есть получим все заказы и добавим информацию по клиенту и связанному товару:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Customers.FirstName, Products.ProductName, Orders.CreatedAt \r\nFROM Orders, Customers, Products\r\nWHERE Orders.CustomerId = Customers.Id AND Orders.ProductId=Products.Id;\r\n</pre>\r\n<p>Так как здесь соединяются три таблицы, то необходимо применить как минимум два условия. Ключевой таблицей остается Orders, из которой \r\nизвлекаются все заказы, а затем к ней подсоединяются данные по клиенту по условию <code>Orders.CustomerId = Customers.Id</code> и данные по товару по условию <code>Orders.ProductId=Products.Id</code></p>\r\n<img src=\"pics/8.3.png\" alt=\"Соединение таблиц без JOIN в PostgreSQL\">\r\n<p>Поскольку в данном случае названия таблиц сильно увеличивают код, то мы его можем сократить за счет использования псевдонимов таблиц:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT C.FirstName, P.ProductName, O.CreatedAt \r\nFROM Orders AS O, Customers AS C, Products AS P\r\nWHERE O.CustomerId = C.Id AND O.ProductId=P.Id;\r\n</pre>\r\n<p>Если необходимо при использовании псевдонима выбрать все столбцы из определенной таблицы, то можно использовать звездочку:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT C.FirstName, P.ProductName, O.*\r\nFROM Orders AS O, Customers AS C, Products AS P\r\nWHERE O.CustomerId = C.Id AND O.ProductId=P.Id;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"5.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.2.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.2.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "INNER JOIN", "text": "\n INNER JOIN Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Еще одним способом соединения таблиц является использование оператора  JOIN  или  INNER JOIN . \r\nОн представляет так называемое внутренее соединение. Его формальный синтаксис: \r\n \r\nSELECT столбцы\r\nFROM таблица1\r\n\t[INNER] JOIN таблица2\r\n\tON условие1\r\n\t[[INNER] JOIN таблица3\r\n\tON условие2]\r\n \r\n После оператора  JOIN  идет название второй таблицы, данные которой надо добавить в выборку. Перед JOIN можно указывать \r\nнеобязательный оператор  INNER . Его наличие или отсутствие ни на что не влияет. Далее \r\nпосле ключевого слова  ON  указывается условие соединения. Это условие устанавливает, как две таблицы будут сравниваться. \r\nКак правило, для соединения применяется первичный ключ главной таблицы и внешний ключ зависимой таблицы. \r\n Возьмем таблицы с данными из прошлой темы: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n \r\n Используя JOIN, выберем все заказы и добавим к ним информацию о товарах: \r\n \r\nSELECT Orders.CreatedAt, Orders.ProductCount, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId;\r\n \r\n Поскольку таблицы могут содержать столбцы с одинаковыми названиями, то при указании столбцов для выборки указывается их полное имя вместе с именем таблицы, например, \r\n\"Orders.ProductCount\". \r\n \r\n С помощью псевдонимов, определяемых через оператор AS, можно сократить код: \r\n \r\nSELECT O.CreatedAt, O.ProductCount, P.ProductName \r\nFROM Orders AS O\r\nJOIN Products AS P\r\nON P.Id = O.ProductId;\r\n \r\n Подобным образом мы можем присоединять и другие таблицы. Например, добавим к заказу информацию о покупателе из таблицы Customers: \r\n \r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId\r\nJOIN Customers ON Customers.Id=Orders.CustomerId;\r\n \r\n \r\n Благодаря соединению таблиц мы можем использовать их столбцы для фильтрации выборки или ее сортировки: \r\n \r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId\r\nJOIN Customers ON Customers.Id=Orders.CustomerId\r\nWHERE Products.Price > 45000\r\nORDER BY Customers.FirstName;\r\n \r\n Условия после ключевого слова ON могут быть более сложными по составу. Например, выбирем все заказы на товары, производителем которых является Apple. \r\n \r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId AND Products.Company='Apple'\r\nJOIN Customers ON Customers.Id=Orders.CustomerId\r\nORDER BY Customers.FirstName;\r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>INNER JOIN</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Еще одним способом соединения таблиц является использование оператора <span class=\"b\">JOIN</span> или <span class=\"b\">INNER JOIN</span>. \r\nОн представляет так называемое внутренее соединение. Его формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT столбцы\r\nFROM таблица1\r\n\t[INNER] JOIN таблица2\r\n\tON условие1\r\n\t[[INNER] JOIN таблица3\r\n\tON условие2]\r\n</pre>\r\n<p>После оператора <span class=\"b\">JOIN</span> идет название второй таблицы, данные которой надо добавить в выборку. Перед JOIN можно указывать \r\nнеобязательный оператор <span class=\"b\">INNER</span>. Его наличие или отсутствие ни на что не влияет. Далее \r\nпосле ключевого слова <span class=\"b\">ON</span> указывается условие соединения. Это условие устанавливает, как две таблицы будут сравниваться. \r\nКак правило, для соединения применяется первичный ключ главной таблицы и внешний ключ зависимой таблицы.</p>\r\n<p>Возьмем таблицы с данными из прошлой темы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n</pre>\r\n<p>Используя JOIN, выберем все заказы и добавим к ним информацию о товарах:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Orders.CreatedAt, Orders.ProductCount, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId;\r\n</pre>\r\n<p>Поскольку таблицы могут содержать столбцы с одинаковыми названиями, то при указании столбцов для выборки указывается их полное имя вместе с именем таблицы, например, \r\n\"Orders.ProductCount\".</p>\r\n<img src=\"pics/8.4.png\" alt=\"JOIN ON в PostgreSQL\">\r\n<p>С помощью псевдонимов, определяемых через оператор AS, можно сократить код:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT O.CreatedAt, O.ProductCount, P.ProductName \r\nFROM Orders AS O\r\nJOIN Products AS P\r\nON P.Id = O.ProductId;\r\n</pre>\r\n<p>Подобным образом мы можем присоединять и другие таблицы. Например, добавим к заказу информацию о покупателе из таблицы Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId\r\nJOIN Customers ON Customers.Id=Orders.CustomerId;\r\n</pre>\r\n<img src=\"pics/8.5.png\" alt=\"Соединение таблиц в PostgreSQL\">\r\n<p>Благодаря соединению таблиц мы можем использовать их столбцы для фильтрации выборки или ее сортировки:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId\r\nJOIN Customers ON Customers.Id=Orders.CustomerId\r\nWHERE Products.Price &gt; 45000\r\nORDER BY Customers.FirstName;\r\n</pre>\r\n<p>Условия после ключевого слова ON могут быть более сложными по составу. Например, выбирем все заказы на товары, производителем которых является Apple.</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Orders.CreatedAt, Customers.FirstName, Products.ProductName \r\nFROM Orders\r\nJOIN Products ON Products.Id = Orders.ProductId AND Products.Company='Apple'\r\nJOIN Customers ON Customers.Id=Orders.CustomerId\r\nORDER BY Customers.FirstName;\r\n</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.1.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.3.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.3.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 23.03.2018", "title": "OUTER JOIN и CROSS JOIN", "text": "\n OUTER JOIN и CROSS JOIN Последнее обновление: 23.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n OUTER JOIN или внешнее соединение позволяет возвратить все строки одной или двух таблиц, которые участвуют в соединении. \r\n Outer Join имеет следующий формальный синтаксис: \r\n \r\nSELECT столбцы\r\nFROM таблица1\r\n\t{LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1\r\n\t[{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]...\r\n \r\n Перед оператором  JOIN  указывается одно из ключевых слов  LEFT , \r\n RIGHT  или  FULL , которые определяют тип соединения: \r\n \r\n LEFT : выборка будет содержать все строки из первой или левой таблицы \r\n RIGHT : выборка будет содержать все строки из второй или правой таблицы \r\n FULL : выборка будет содержать все строки из обеих таблиц \r\n \r\n Перед оператором JOIN может указываться ключевое слово  OUTER , но его применение необязательно. \r\nПосле JOIN указывается присоединяемая таблица, а затем идет условие соединения после оператора ON. \r\n К примеру, возьмем следующие таблицы: \r\n \r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n \r\n И соединим таблицы Orders и Customers: \r\n \r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders LEFT JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n \r\n Таблица Orders является первой или левой таблицей, а таблица Customers - правой таблицей. Поэтому, так как здесь используется \r\nвыборка по левой таблице, то вначале будут выбираться все строки из Orders, а затем к ним по условию  Orders.CustomerId = Customers.Id  будут \r\nдобавляться связанные строки из Customers. \r\n \r\n По вышеприведенному результату может показаться, что левостороннее соединение аналогично INNER Join, но это не так. \r\nInner Join объединяет строки из дух таблиц при соответствии условию. Если одна из таблиц содержит строки, которые не соответствуют этому условию, то данные строки \r\nне включаются в выходную выборку. Left Join выбирает все строки первой таблицы и затем присоединяет к ним строки правой таблицы. \r\nК примеру, возьмем таблицу Customers и добавим к покупателям информацию об их заказах: \r\n \r\n-- INNER JOIN\r\nSELECT FirstName, CreatedAt, ProductCount, Price \r\nFROM Customers JOIN Orders \r\nON Orders.CustomerId = Customers.Id;\r\n\r\n--LEFT JOIN\r\nSELECT FirstName, CreatedAt, ProductCount, Price \r\nFROM Customers LEFT JOIN Orders \r\nON Orders.CustomerId = Customers.Id;\r\n \r\n \r\n Изменим в примере выше тип соединения на правостороннее: \r\n \r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders RIGHT JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n \r\n Теперь будут выбираться все строки из Customers, а к ним уже будет присоединяться связанные по условию строки из таблицы Orders: \r\n \r\n Поскольку один из покупателей из таблицы Customers не имеет связанных заказов из Orders, то соответствующие столбцы, которые берутся из Orders, \r\nбудут иметь значение NULL. \r\n Полное соединение (FULL JOIN) объединяет обе таблицы: \r\n \r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders FULL JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n \r\n Используем левостороннее соединение для добавления к заказам информации о пользователях и товарах: \r\n \r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nLEFT JOIN Products ON Orders.ProductId = Products.Id;\r\n \r\n \r\n И также можно применять более комплексные условия с фильтрацией и сортировкой. Например, выберем все заказы с информацией о клиентах и товарах по тем товарам, \r\nу которых цена больше 55000, и отсортируем по дате заказа: \r\n \r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nLEFT JOIN Products ON Orders.ProductId = Products.Id\r\nWHERE Products.Price > 55000\r\nORDER BY Orders.CreatedAt;\r\n \r\n \r\n Или выберем всех пользователей из Customers, у которых нет заказов в таблице Orders: \r\n \r\nSELECT FirstName FROM Customers\r\nLEFT JOIN Orders ON Customers.Id = Orders.CustomerId\r\nWHERE Orders.CustomerId IS NULL;\r\n \r\n Также можно комбинировать Inner Join и Outer Join: \r\n \r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nJOIN Products ON Orders.ProductId = Products.Id AND Products.Price > 45000\r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nORDER BY Orders.CreatedAt;\r\n \r\n Вначале по условию к таблице Orders через Inner Join присоединяется связанная информация из Products, затем через Outer Join \r\nдобавляется информация из таблицы Customers. \r\n Cross Join \r\n Cross Join или перекрестное соединение создает набор строк, где каждая строка из одной таблицы соединяется с каждой строкой из второй таблицы. \r\nНапример, соединим таблицу заказов Orders и таблицу покупателей Customers: \r\n \r\nSELECT * FROM Orders CROSS JOIN Customers;\r\n \r\n \r\n Если в таблице Orders 3 строки, а в таблице Customers то же три строки, то в результате перекрестного соединения создается 3 * 3 = 9 строк вне зависимости, \r\nсвязаны ли данные строки или нет. \r\n При неявном перекрестном соединении можно опустить оператор CROSS JOIN и просто перечислить все получаемые таблицы: \r\n SELECT * FROM Orders, Customers; \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>OUTER JOIN и CROSS JOIN</h2><div class=\"date\">Последнее обновление: 23.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>OUTER JOIN или внешнее соединение позволяет возвратить все строки одной или двух таблиц, которые участвуют в соединении.</p>\r\n<p>Outer Join имеет следующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT столбцы\r\nFROM таблица1\r\n\t{LEFT|RIGHT|FULL} [OUTER] JOIN таблица2 ON условие1\r\n\t[{LEFT|RIGHT|FULL} [OUTER] JOIN таблица3 ON условие2]...\r\n</pre>\r\n<p>Перед оператором <span class=\"b\">JOIN</span> указывается одно из ключевых слов <span class=\"b\">LEFT</span>, \r\n<span class=\"b\">RIGHT</span> или <span class=\"b\">FULL</span>, которые определяют тип соединения:</p>\r\n<ul>\r\n<li><p><span class=\"b\">LEFT</span>: выборка будет содержать все строки из первой или левой таблицы</p></li>\r\n<li><p><span class=\"b\">RIGHT</span>: выборка будет содержать все строки из второй или правой таблицы</p></li>\r\n<li><p><span class=\"b\">FULL</span>: выборка будет содержать все строки из обеих таблиц</p></li>\r\n</ul>\r\n<p>Перед оператором JOIN может указываться ключевое слово <span class=\"b\">OUTER</span>, но его применение необязательно. \r\nПосле JOIN указывается присоединяемая таблица, а затем идет условие соединения после оператора ON.</p>\r\n<p>К примеру, возьмем следующие таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Products\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductName VARCHAR(30) NOT NULL,\r\n    Company VARCHAR(20) NOT NULL,\r\n    ProductCount INTEGER DEFAULT 0,\r\n    Price NUMERIC NOT NULL\r\n);\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(30) NOT NULL\r\n);\r\nCREATE TABLE Orders\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    ProductId INTEGER NOT NULL REFERENCES Products(Id) ON DELETE CASCADE,\r\n    CustomerId INTEGER NOT NULL REFERENCES Customers(Id) ON DELETE CASCADE,\r\n    CreatedAt DATE NOT NULL,\r\n    ProductCount INTEGER DEFAULT 1,\r\n    Price NUMERIC NOT NULL\r\n);\r\n</pre>\r\n<p>И соединим таблицы Orders и Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders LEFT JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n</pre>\r\n<p>Таблица Orders является первой или левой таблицей, а таблица Customers - правой таблицей. Поэтому, так как здесь используется \r\nвыборка по левой таблице, то вначале будут выбираться все строки из Orders, а затем к ним по условию <code>Orders.CustomerId = Customers.Id</code> будут \r\nдобавляться связанные строки из Customers.</p>\r\n<img src=\"pics/8.6.png\" alt=\"Левостороннее соединение OUTER JOIN в PostgreSQL\">\r\n<p>По вышеприведенному результату может показаться, что левостороннее соединение аналогично INNER Join, но это не так. \r\nInner Join объединяет строки из дух таблиц при соответствии условию. Если одна из таблиц содержит строки, которые не соответствуют этому условию, то данные строки \r\nне включаются в выходную выборку. Left Join выбирает все строки первой таблицы и затем присоединяет к ним строки правой таблицы. \r\nК примеру, возьмем таблицу Customers и добавим к покупателям информацию об их заказах:</p>\r\n<pre class=\"brush:sql;\">\r\n-- INNER JOIN\r\nSELECT FirstName, CreatedAt, ProductCount, Price \r\nFROM Customers JOIN Orders \r\nON Orders.CustomerId = Customers.Id;\r\n\r\n--LEFT JOIN\r\nSELECT FirstName, CreatedAt, ProductCount, Price \r\nFROM Customers LEFT JOIN Orders \r\nON Orders.CustomerId = Customers.Id;\r\n</pre>\r\n<img src=\"pics/8.7.png\" alt=\"INNER join vs left join в PostgreSQL\">\r\n<p>Изменим в примере выше тип соединения на правостороннее:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders RIGHT JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n</pre>\r\n<p>Теперь будут выбираться все строки из Customers, а к ним уже будет присоединяться связанные по условию строки из таблицы Orders:</p>\r\n<img src=\"pics/8.8.png\" alt=\"OUTER JOIN в PostgreSQL\">\r\n<p>Поскольку один из покупателей из таблицы Customers не имеет связанных заказов из Orders, то соответствующие столбцы, которые берутся из Orders, \r\nбудут иметь значение NULL.</p>\r\n<p>Полное соединение (FULL JOIN) объединяет обе таблицы:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, CreatedAt, ProductCount, Price, ProductId \r\nFROM Orders FULL JOIN Customers \r\nON Orders.CustomerId = Customers.Id;\r\n</pre>\r\n<p>Используем левостороннее соединение для добавления к заказам информации о пользователях и товарах:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nLEFT JOIN Products ON Orders.ProductId = Products.Id;\r\n</pre>\r\n<img src=\"pics/8.9.png\" alt=\"Left Join и соединение таблиц в PostgreSQL\">\r\n<p>И также можно применять более комплексные условия с фильтрацией и сортировкой. Например, выберем все заказы с информацией о клиентах и товарах по тем товарам, \r\nу которых цена больше 55000, и отсортируем по дате заказа:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nLEFT JOIN Products ON Orders.ProductId = Products.Id\r\nWHERE Products.Price &gt; 55000\r\nORDER BY Orders.CreatedAt;\r\n</pre>\r\n<img src=\"pics/8.10.png\" alt=\"LEFT JOIN с фильтрацией и сортировкой в PostgreSQL\">\r\n<p>Или выберем всех пользователей из Customers, у которых нет заказов в таблице Orders:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName FROM Customers\r\nLEFT JOIN Orders ON Customers.Id = Orders.CustomerId\r\nWHERE Orders.CustomerId IS NULL;\r\n</pre>\r\n<p>Также можно комбинировать Inner Join и Outer Join:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Customers.FirstName, Orders.CreatedAt, \r\n       Products.ProductName, Products.Company\r\nFROM Orders \r\nJOIN Products ON Orders.ProductId = Products.Id AND Products.Price &gt; 45000\r\nLEFT JOIN Customers ON Orders.CustomerId = Customers.Id\r\nORDER BY Orders.CreatedAt;\r\n</pre>\r\n<p>Вначале по условию к таблице Orders через Inner Join присоединяется связанная информация из Products, затем через Outer Join \r\nдобавляется информация из таблицы Customers.</p>\r\n<h3>Cross Join</h3>\r\n<p>Cross Join или перекрестное соединение создает набор строк, где каждая строка из одной таблицы соединяется с каждой строкой из второй таблицы. \r\nНапример, соединим таблицу заказов Orders и таблицу покупателей Customers:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT * FROM Orders CROSS JOIN Customers;\r\n</pre>\r\n<img src=\"pics/8.11.png\" alt=\"CROSS JOIN в PostgreSQL\">\r\n<p>Если в таблице Orders 3 строки, а в таблице Customers то же три строки, то в результате перекрестного соединения создается 3 * 3 = 9 строк вне зависимости, \r\nсвязаны ли данные строки или нет.</p>\r\n<p>При неявном перекрестном соединении можно опустить оператор CROSS JOIN и просто перечислить все получаемые таблицы:</p>\r\n<pre class=\"brush:sql;\">SELECT * FROM Orders, Customers;</pre>\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.2.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.4.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.4.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 24.03.2018", "title": "Группировка в соединениях", "text": "\n Группировка в соединениях Последнее обновление: 24.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Более сложным вариантом использования соединений INNER/OUTER JOIN представляет их сочетание с выражениями группировки, в частности, с оператором \r\nGROUP BY. Например, выведем для каждого покупателя количество заказов, которые он сделал: \r\n \r\nSELECT FirstName, COUNT(Orders.Id)\r\nFROM Customers JOIN Orders \r\nON Orders.CustomerId = Customers.Id\r\nGROUP BY Customers.Id, Customers.FirstName;\r\n \r\n \r\n Критерием группировки выступают Id и имя покупателя. Выражение SELECT выбирает имя покупателя и количество заказов, используя столбец Id из таблицы Orders. \r\n Так как это INNER JOIN, то в группах будут только те покупатели, у которых есть заказы. \r\n Если нужно получить также и тех покупателей, у которых нет заказов, то можно использовать OUTER JOIN: \r\n \r\nSELECT FirstName, COUNT(Orders.Id)\r\nFROM Customers LEFT JOIN Orders \r\nON Orders.CustomerId = Customers.Id\r\nGROUP BY Customers.Id, Customers.FirstName;\r\n \r\n \r\n Или выведем товары с общей суммой сделанных заказов: \r\n \r\nSELECT Products.ProductName, Products.Company, \r\n\t\tSUM(Orders.ProductCount * Orders.Price) AS TotalSum\r\nFROM Products LEFT JOIN Orders\r\nON Orders.ProductId = Products.Id\r\nGROUP BY Products.Id, Products.ProductName, Products.Company;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Группировка в соединениях</h2><div class=\"date\">Последнее обновление: 24.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Более сложным вариантом использования соединений INNER/OUTER JOIN представляет их сочетание с выражениями группировки, в частности, с оператором \r\nGROUP BY. Например, выведем для каждого покупателя количество заказов, которые он сделал:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, COUNT(Orders.Id)\r\nFROM Customers JOIN Orders \r\nON Orders.CustomerId = Customers.Id\r\nGROUP BY Customers.Id, Customers.FirstName;\r\n</pre>\r\n<img src=\"pics/8.12.png\" alt=\"Группировка в INNER JOIN в PostgreSQL\">\r\n<p>Критерием группировки выступают Id и имя покупателя. Выражение SELECT выбирает имя покупателя и количество заказов, используя столбец Id из таблицы Orders.</p>\r\n<p>Так как это INNER JOIN, то в группах будут только те покупатели, у которых есть заказы.</p>\r\n<p>Если нужно получить также и тех покупателей, у которых нет заказов, то можно использовать OUTER JOIN:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, COUNT(Orders.Id)\r\nFROM Customers LEFT JOIN Orders \r\nON Orders.CustomerId = Customers.Id\r\nGROUP BY Customers.Id, Customers.FirstName;\r\n</pre>\r\n<img src=\"pics/8.13.png\" alt=\"Группировка в OUTER LEFT JOIN в PostgreSQL\">\r\n<p>Или выведем товары с общей суммой сделанных заказов:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT Products.ProductName, Products.Company, \r\n\t\tSUM(Orders.ProductCount * Orders.Price) AS TotalSum\r\nFROM Products LEFT JOIN Orders\r\nON Orders.ProductId = Products.Id\r\nGROUP BY Products.Id, Products.ProductName, Products.Company;\r\n</pre>\r\n<img src=\"pics/8.14.png\" alt=\"GROUP BY и JOIN в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.3.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.5.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.5.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 24.03.2018", "title": "Объединение множеств. UNION", "text": "\n Объединение множеств. UNION Последнее обновление: 24.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор  UNION  позволяет объединить два множества (условно две таблицы). Но в отличие от inner/outer join \r\nобъединения соединяют не столбцы разных таблиц, а два однотипных набора в один. Формальный синтаксис объединения: \r\n \r\nSELECT_выражение1\r\nUNION [ALL] SELECT_выражение2\r\n[UNION [ALL] SELECT_выражениеN]\r\n \r\n Например, пусть в базе данных будут две отдельные таблицы для клиентов банка (таблица Customers) и для сотрудников банка (таблица Employees): \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n \r\n Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами - \r\nименем (FirstName) и фамилией (LastName). Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц: \r\n \r\nSELECT FirstName, LastName \r\nFROM Customers\r\nUNION SELECT FirstName, LastName FROM Employees;\r\n \r\n В данном случае из первой таблицы выбираются два значения - имя и фамилия клиента. Из второй таблицы Employees также \r\nвыбираются два значения - имя и фамилия сотрудников. То есть при объединении количество выбираемых столбцов и их тип \r\nсовпадают для обеих выборок. \r\n \r\n Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются. \r\nВ случае с таблицами Customers и Employees сотрудники банка могут быть одновременно его клиентами и содержаться в обеих таблицах. \r\nПри объединении в примерах выше всех дублирующиеся строки удалялись. Например, исходя из начальных данных, мы видим, что два человека: Tom Smith и Mark Adams располагаются в обеих таблицах. Однако при объединении дубли не считаются, \r\nпоэтому один человек учитывается только один раз. \r\n Если же необходимо при объединении сохранить все, в том числе повторяющиеся строки, то для этого необходимо использовать оператор  ALL : \r\n \r\nSELECT FirstName, LastName\r\nFROM Customers\r\nUNION ALL SELECT FirstName, LastName \r\nFROM Employees;\r\n \r\n \r\n При этом названия столбцов объединенной выборки будут совпадать с названия столбцов первой выборки. И если мы захотим при этом еще произвести сортировку, \r\nто в выражениях  ORDER BY  необходимо ориентироваться именно на названия столбцов первой выборки: \r\n \r\nSELECT FirstName || ' ' || LastName AS FullName\r\nFROM Customers\r\nUNION SELECT FirstName || ' ' || LastName AS EmployeeName \r\nFROM Employees\r\nORDER BY FullName;\r\n \r\n В данном случае каждая выборка имеет по одному столбцу, который представляет объединение имени и фамилии клиента или сотрудника. \r\nДля объединения строк применяется оператор  || . Но в случае с клиентами столбец будет называться FullName, а в случае с \r\nсотрудниками - EmployeeName. Тем не менее для сортировки применяется название столбца из первой выборки и он же будет в результирующей выборке: \r\n \r\n Если же в одной выборке больше столбцов, чем в другой, то они не смогут быть объединены. Например, в следующем случае объединение завершится с ошибкой: \r\n \r\nSELECT FirstName, LastName, AccountSum\r\nFROM Customers\r\nUNION SELECT FirstName, LastName \r\nFROM Employees;\r\n \r\n Также соответствующие столбцы должны соответствовать по типу. Так, следующий пример завершится с ошибкой из-за не соответствия по типу данных: \r\n \r\nSELECT FirstName, LastName\r\nFROM Customers\r\nUNION SELECT Id, LastName \r\nFROM Employees;\r\n \r\n Здесь первый столбец первой выборки имеет тип CHARACTER VARYING, то есть хранит строку. Первый столбец второй выборки - Id имеет тип INTEGER, то есть \r\nхранит число. \r\n Объединять выборки можно и из одной и той же таблицы. Например, в зависимости от суммы на счете клиента нам надо начислять ему определенные проценты: \r\n \r\nSELECT FirstName, LastName, AccountSum + AccountSum * 0.1 AS TotalSum \r\nFROM Customers WHERE AccountSum < 3000\r\nUNION SELECT FirstName, LastName, AccountSum + AccountSum * 0.3 AS TotalSum \r\nFROM Customers WHERE AccountSum >= 3000\r\n \r\n В данном случае если сумма меньше 3000, то начисляются проценты в размере 10% от суммы на счете. Если на счете больше 3000, то \r\nпроценты увеличиваются до 30%. \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Объединение множеств. UNION</h2><div class=\"date\">Последнее обновление: 24.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор <span class=\"b\">UNION</span> позволяет объединить два множества (условно две таблицы). Но в отличие от inner/outer join \r\nобъединения соединяют не столбцы разных таблиц, а два однотипных набора в один. Формальный синтаксис объединения:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT_выражение1\r\nUNION [ALL] SELECT_выражение2\r\n[UNION [ALL] SELECT_выражениеN]\r\n</pre>\r\n<p>Например, пусть в базе данных будут две отдельные таблицы для клиентов банка (таблица Customers) и для сотрудников банка (таблица Employees):</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n</pre>\r\n<p>Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами - \r\nименем (FirstName) и фамилией (LastName). Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName \r\nFROM Customers\r\nUNION SELECT FirstName, LastName FROM Employees;\r\n</pre>\r\n<p>В данном случае из первой таблицы выбираются два значения - имя и фамилия клиента. Из второй таблицы Employees также \r\nвыбираются два значения - имя и фамилия сотрудников. То есть при объединении количество выбираемых столбцов и их тип \r\nсовпадают для обеих выборок.</p>\r\n<img src=\"pics/8.15.png\" alt=\"Обединение таблиц и оператор UNION в PostgreSQL\">\r\n<p>Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются. \r\nВ случае с таблицами Customers и Employees сотрудники банка могут быть одновременно его клиентами и содержаться в обеих таблицах. \r\nПри объединении в примерах выше всех дублирующиеся строки удалялись. Например, исходя из начальных данных, мы видим, что два человека: Tom Smith и Mark Adams располагаются в обеих таблицах. Однако при объединении дубли не считаются, \r\nпоэтому один человек учитывается только один раз.</p>\r\n<p>Если же необходимо при объединении сохранить все, в том числе повторяющиеся строки, то для этого необходимо использовать оператор <span class=\"b\">ALL</span>:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName\r\nFROM Customers\r\nUNION ALL SELECT FirstName, LastName \r\nFROM Employees;\r\n</pre>\r\n<img src=\"pics/8.17.png\" alt=\"UNION ALL в PostgreSQL\">\r\n<p>При этом названия столбцов объединенной выборки будут совпадать с названия столбцов первой выборки. И если мы захотим при этом еще произвести сортировку, \r\nто в выражениях <span class=\"b\">ORDER BY</span> необходимо ориентироваться именно на названия столбцов первой выборки:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName || ' ' || LastName AS FullName\r\nFROM Customers\r\nUNION SELECT FirstName || ' ' || LastName AS EmployeeName \r\nFROM Employees\r\nORDER BY FullName;\r\n</pre>\r\n<p>В данном случае каждая выборка имеет по одному столбцу, который представляет объединение имени и фамилии клиента или сотрудника. \r\nДля объединения строк применяется оператор <span class=\"b\">||</span>. Но в случае с клиентами столбец будет называться FullName, а в случае с \r\nсотрудниками - EmployeeName. Тем не менее для сортировки применяется название столбца из первой выборки и он же будет в результирующей выборке:</p>\r\n<img src=\"pics/8.16.png\" alt=\"Сортировка в UNION в PostgreSQL\">\r\n<p>Если же в одной выборке больше столбцов, чем в другой, то они не смогут быть объединены. Например, в следующем случае объединение завершится с ошибкой:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName, AccountSum\r\nFROM Customers\r\nUNION SELECT FirstName, LastName \r\nFROM Employees;\r\n</pre>\r\n<p>Также соответствующие столбцы должны соответствовать по типу. Так, следующий пример завершится с ошибкой из-за не соответствия по типу данных:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName\r\nFROM Customers\r\nUNION SELECT Id, LastName \r\nFROM Employees;\r\n</pre>\r\n<p>Здесь первый столбец первой выборки имеет тип CHARACTER VARYING, то есть хранит строку. Первый столбец второй выборки - Id имеет тип INTEGER, то есть \r\nхранит число.</p>\r\n<p>Объединять выборки можно и из одной и той же таблицы. Например, в зависимости от суммы на счете клиента нам надо начислять ему определенные проценты:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName, AccountSum + AccountSum * 0.1 AS TotalSum \r\nFROM Customers WHERE AccountSum &lt; 3000\r\nUNION SELECT FirstName, LastName, AccountSum + AccountSum * 0.3 AS TotalSum \r\nFROM Customers WHERE AccountSum &gt;= 3000\r\n</pre>\r\n<p>В данном случае если сумма меньше 3000, то начисляются проценты в размере 10% от суммы на счете. Если на счете больше 3000, то \r\nпроценты увеличиваются до 30%.</p>\r\n<img src=\"pics/8.18.png\" alt=\"Объединение выборок из той же таблицы в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.4.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.6.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.6.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 24.03.2018", "title": "Разность множеств. EXCEPT", "text": "\n Разность множеств. EXCEPT Последнее обновление: 24.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор  EXCEPT  в PostgreSQL позволяет найти разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй. Для его использования применяется \r\nследующий формальный синтаксис: \r\n \r\nSELECT_выражение1\r\nEXCEPT SELECT_выражение2\r\n \r\n Для примера возьмем таблицы из прошлой темы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n \r\n Таблица Employees содержит данные обо всех сотрудниках банка, а таблица Customers - обо всех клиентах. Но сотрудники банка могут также \r\nбыть его клиентами. И допустим, нам надо найти всех клиентов банка, которые не являются его сотрудниками: \r\n \r\nSELECT FirstName, LastName\r\nFROM Customers\r\nEXCEPT SELECT FirstName, LastName \r\nFROM Employees;\r\n \r\n \r\n Подобным образом можно получить всех сотрудников банка, которые не являются его клиентами: \r\n \r\nSELECT FirstName, LastName\r\nFROM Employees\r\nEXCEPT SELECT FirstName, LastName \r\nFROM Customers;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание Вперед", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Разность множеств. EXCEPT</h2><div class=\"date\">Последнее обновление: 24.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор <span class=\"b\">EXCEPT</span> в PostgreSQL позволяет найти разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй. Для его использования применяется \r\nследующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT_выражение1\r\nEXCEPT SELECT_выражение2\r\n</pre>\r\n<p>Для примера возьмем таблицы из прошлой темы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n</pre>\r\n<p>Таблица Employees содержит данные обо всех сотрудниках банка, а таблица Customers - обо всех клиентах. Но сотрудники банка могут также \r\nбыть его клиентами. И допустим, нам надо найти всех клиентов банка, которые не являются его сотрудниками:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName\r\nFROM Customers\r\nEXCEPT SELECT FirstName, LastName \r\nFROM Employees;\r\n</pre>\r\n<img src=\"pics/8.19.png\" alt=\"Разность таблиц и оператор EXCEPT в PostgreSQL\">\r\n<p>Подобным образом можно получить всех сотрудников банка, которые не являются его клиентами:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName\r\nFROM Employees\r\nEXCEPT SELECT FirstName, LastName \r\nFROM Customers;\r\n</pre>\r\n<img src=\"pics/8.20.png\" alt=\"Разность множеств и EXCEPT в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.5.php\">Назад</a><a href=\"./\">Содержание</a><a href=\"6.7.php\">Вперед</a></p></div></div>"},
{"source_link": "https://metanit.com/sql/postgresql/6.7.php", "source": "https://metanit.com/", "posted": "Последнее обновление: 24.03.2018", "title": "Пересечение множеств. INTERSECT", "text": "\n Пересечение множеств. INTERSECT Последнее обновление: 24.03.2018 \n\n \n \n \n \n \n \n \n \n \n\n \n\n \n \n \n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n\n \n\n Оператор  INTERSECT  позволяет найти общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения \r\nмножеств. Для его использования применяется следующий формальный синтаксис: \r\n \r\nSELECT_выражение1\r\nINTERSECT SELECT_выражение2\r\n \r\n Для примера возьмем таблицы из прошлой темы: \r\n \r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n \r\n В таблице Customers хранятся все клиенты банка, а в таблице Employees - все его сотрудники. При этом сотрудники банка могут быть одновременно и \r\nклиентами этого банка, поэтому их данные могут храниться сразу в двух таблицах. Найдем всех сотрудников банка, которые одновременно \r\nявляются его клиентами. То есть нам надо найти общие элементы двух выборок: \r\n \r\nSELECT FirstName, LastName\r\nFROM Employees\r\nINTERSECT SELECT FirstName, LastName \r\nFROM Customers;\r\n \r\n \n \n \n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n \n \n \n \n(adsbygoogle = window.adsbygoogle || []).push({});\n \n \n\n\n Назад Содержание", "html_body": "<div class=\"articleText\" id=\"articleText\">\n<h2>Пересечение множеств. INTERSECT</h2><div class=\"date\">Последнее обновление: 24.03.2018</div>\n\n<div class=\"socialBlock\">\n<div class=\"share socialtop\">\n<ul>\n<li><a title=\"Поделиться в Вконтакте\" rel=\"nofollow\" class=\"fa fa-lg fa-vk\"></a></li>\n<li><a title=\"Поделиться в Одноклассниках\" rel=\"nofollow\" class=\"fa fa-lg fa-odnoklassniki\"></a></li>\n<li><a title=\"Поделиться в Твиттере\" rel=\"nofollow\" class=\"fa fa-lg fa-twitter\"></a></li>\n<li><a title=\"Поделиться в Фейсбуке\" rel=\"nofollow\" class=\"fa fa-lg fa-facebook\"></a></li>\n</ul>\n</div>\n\n</div>\n\n<div style=\"margin-top:23px;margin-left:6px;\"><div></div>\n<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n<style>\n.footer-adaptive { width: 320px; height: 100px; }\n@media(min-width: 480px) { .footer-adaptive { width: 468px; height: 60px; } }\n@media(min-width: 760px) { .footer-adaptive { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .footer-adaptive { width: 468px; height: 60px;  } }\n@media(min-width: 1122px) { .footer-adaptive{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .footer-adaptive { width: 970px; height: 90px;} }\n</style>\n<!-- footer_adaptive -->\n<ins class=\"adsbygoogle footer-adaptive\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"9659512088\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n</div>\n\n<p>Оператор <span class=\"b\">INTERSECT</span> позволяет найти общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения \r\nмножеств. Для его использования применяется следующий формальный синтаксис:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT_выражение1\r\nINTERSECT SELECT_выражение2\r\n</pre>\r\n<p>Для примера возьмем таблицы из прошлой темы:</p>\r\n<pre class=\"brush:sql;\">\r\nCREATE TABLE Customers\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL,\r\n    AccountSum NUMERIC DEFAULT 0\r\n);\r\nCREATE TABLE Employees\r\n(\r\n    Id SERIAL PRIMARY KEY,\r\n    FirstName VARCHAR(20) NOT NULL,\r\n    LastName VARCHAR(20) NOT NULL\r\n);\r\n \r\nINSERT INTO Customers(FirstName, LastName, AccountSum) VALUES\r\n('Tom', 'Smith', 2000),\r\n('Sam', 'Brown', 3000),\r\n('Paul', 'Ins', 4200),\r\n('Victor', 'Baya', 2800),\r\n('Mark', 'Adams', 2500),\r\n('Tim', 'Cook', 2800);\r\n \r\nINSERT INTO Employees(FirstName, LastName) VALUES\r\n('Homer', 'Simpson'),\r\n('Tom', 'Smith'),\r\n('Mark', 'Adams'),\r\n('Nick', 'Svensson');\r\n</pre>\r\n<p>В таблице Customers хранятся все клиенты банка, а в таблице Employees - все его сотрудники. При этом сотрудники банка могут быть одновременно и \r\nклиентами этого банка, поэтому их данные могут храниться сразу в двух таблицах. Найдем всех сотрудников банка, которые одновременно \r\nявляются его клиентами. То есть нам надо найти общие элементы двух выборок:</p>\r\n<pre class=\"brush:sql;\">\r\nSELECT FirstName, LastName\r\nFROM Employees\r\nINTERSECT SELECT FirstName, LastName \r\nFROM Customers;\r\n</pre>\r\n<img src=\"pics/8.21.png\" alt=\"Пересечение множеств и INTERSECT в PostgreSQL\">\n<div style=\"margin-top:25px;clear:both;\">\n<style>\n.metanit-rect { width: 300px; height: 250px; }\n@media(min-width: 500px) { .metanit-rect { width: 336px; height: 280px; } }\n@media(min-width: 760px) { .metanit-rect { width: 728px; height: 90px;  } }\n@media(min-width: 1000px) { .metanit-rect { width: 336px; height: 280px;  } }\n@media(min-width: 1122px) { .metanit-rect{ width: 728px; height: 90px;} }\n@media(min-width: 1400px) { .metanit-rect{ width: 970px; height: 90px;} }\n</style>\n<!-- metanit_rect -->\n<ins class=\"adsbygoogle metanit-rect\" style=\"display:inline-block\" data-ad-client=\"ca-pub-3716042175333627\" data-ad-slot=\"3119477283\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n</div>\n\n\n<div class=\"nav\"><p><a href=\"6.6.php\">Назад</a><a href=\"./\">Содержание</a></p></div></div>"}
]